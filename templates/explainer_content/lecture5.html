
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>المحاضرة الخامسة: المؤشرات والذاكرة الديناميكية</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
 body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif, 'Traditional Arabic';
        direction: rtl;
        /* This is key: we align the container itself to the right */
        text-align: right;
        background-color: #f8f9fa;
        line-height: 1.8;
        padding: 1rem;
        /* Important: Prevents the body from creating its own scrollbars prematurely */
        overflow-x: hidden;
    }

    /* --- START OF THE MAIN FIX --- */
    .container {
        /* This makes the container shrink-to-fit its widest child (the code block) */
        display: inline-block;
        /* Ensure text inside the container is aligned right by default */
        text-align: right;

        /* These are from your original Bootstrap, we keep them */
        padding-left: 15px;
        padding-right: 15px;

        /* We remove any 'max-width' that might limit the container from growing */
        max-width: none;
    }
    /* --- END OF THE MAIN FIX --- */

    /* العناوين */
    h1, h2, h3, h4, h5 {
        color: #0d6efd;
        margin-top: 2rem;
        border-bottom: 1px solid #ddd;
        padding-bottom: 0.5rem;
    }

    /* الفقرات والقوائم */
    p, li {
        margin-bottom: 1rem;
    }
    ol, ul {
          padding-left: 0rem;

    }

    /* كود البرمجة */
    code {
        background-color: #e9ecef;
        padding: 0.2em 0.4em;
        border-radius: 4px;
        font-size: 90%;
        color: #d63384;
        direction: ltr;
        text-align: left;
        display: inline-block;
    }
    pre code {
        color: inherit;
        background-color: transparent;
        padding: 0;
    }

    pre {
        /* 'display: block' is fine now, it will just fill the width of its parent (.container) */
        display: block;
        padding: 1rem;
        margin: 1rem 0;
        background-color: #fff;
        border: 1px solid #ddd;
        box-sizing: border-box;
        white-space: pre;
        text-align: left;

        /* We still let the code content overflow */
        overflow-x: visible;
    }

    /* ملاحظات توضيحية */
    .note, .warning {

        background-color: #fff3cd;
        border-right: 5px solid #ffc107;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 3px;
    }
    .summary-box {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        padding: 1.5rem;
        margin-top: 2rem;
        border-radius: 5px;
    }

</style>
</head>
<body>
    <!-- === NEW BUTTON ADDED HERE === -->
<div id="action-buttons-container">
    <a href="#" class="btn btn-secondary shadow" onclick="window.close(); return false;">رجوع</a>
    <a href="#" class="btn btn-info shadow" onclick="openInNewTab(); return false;">فتح في تبويب جديد</a>
</div>
<script>
function openInNewTab() {
  window.open(window.location.href );
}
</script>
<!-- ======================================= -->
<div class="container py-4">

    <h3>المحاضرة الخامسة: المؤشرات (Pointers) والذاكرة الديناميكية</h3>
    <p>أهلاً بك! دعنا نلخص أهم النقاط في المحاضرة الخامسة حول المؤشرات (Pointers) في لغة C++، مع التركيز على المفاهيم الأساسية، الأمثلة البرمجية، والنقاط المهمة التي ذكر المحاضر أنها قد تكون في الامتحان.</p>

    <h4>1. مقدمة عن المؤشرات (Pointers) وعملياتها (Operations)</h4>
    <p>المؤشر (<code>Pointer</code>) هو متغير (<code>variable</code>) يقوم بتخزين عنوان (<code>address</code>) في الذاكرة. على عكس المتغيرات العادية التي تخزن قيمة مباشرة، المؤشر يخزن عنوان لمتغير آخر.</p>

    <h5>حجم المتغيرات وحركة المؤشر</h5>
    <p>المحاضر يؤكد أنه عند التعامل مع المؤشرات، فإن عمليات الزيادة (<code>increment</code>) أو النقصان (<code>decrement</code>) لا تتم بـ "واحد صحيح" بل بـ "وحدة واحدة" (<code>one unit</code>). هذه الوحدة تعتمد على نوع البيانات (<code>data type</code>) التي يشير إليها المؤشر.</p>
    <div class="note">
        <strong>نقطة مهمة للامتحان:</strong> لماذا نهتم عند تعريف المؤشر أن نحدد نوعه (مثل <code>int*</code> أو <code>float*</code>)؟ الإجابة هي أن هذا النوع يحدد حجم "الوحدة" التي سيتحرك بها المؤشر عند الزيادة أو النقصان.
        <ul>
            <li>إذا كان المؤشر يشير إلى <code>int</code> (أربعة بايت)، فإن <code>ptr++</code> سيقدم المؤشر بمقدار 4 بايتات (أي ينتقل إلى بداية الـ <code>int</code> التالي).</li>
            <li>إذا كان يشير إلى <code>double</code> (ثمانية بايت)، فإن <code>ptr++</code> سيقدم المؤشر بمقدار 8 بايتات.</li>
        </ul>
    </div>

    <h4>2. استدعاء الدوال (Function Calls): Call by Value vs. Call by Address</h4>
    <p>لتحقيق تبادل القيم بين متغيرين في دالة (مثل دالة <code>swap</code>)، هناك طريقتان رئيسيتان لاستدعاء الدوال:</p>

    <h5>Call by Value (أو Call by Copy)</h5>
    <ul>
        <li>عند استدعاء الدالة، يتم تمرير نسخة (<code>copy</code>) من قيم المتغيرات إلى المعاملات (<code>parameters</code>) الخاصة بالدالة.</li>
        <li>أي تغييرات تحدث على هذه النسخ داخل الدالة <strong>لا تؤثر</strong> على المتغيرات الأصلية في الدالة التي قامت بالاستدعاء (مثل <code>main</code>).</li>
        <li>المحاضر شبه هذا بأنك تأخذ صورة من ورقة وتعدل عليها ثم تقطعها وترميها؛ الورقة الأصلية لا تتغير.</li>
    </ul>
    <pre><code>// مثال على Call by Value لدالة swap
void swap(int x, int y) { // x and y are copies
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 3;
    int b = 4;
    swap(a, b); // Pass copies of a and b
    // After swap, a will still be 3 and b will still be 4
    return 0;
}</code></pre>

    <h5>Call by Address (أو Call by Pointer)</h5>
    <ul>
        <li>لحل مشكلة <code>Call by Value</code> (عدم القدرة على تعديل المتغيرات الأصلية)، يتم تمرير عناوين (<code>addresses</code>) المتغيرات بدلاً من قيمها.</li>
        <li>تستقبل الدالة هذه العناوين في معاملات (<code>parameters</code>) من نوع مؤشر (<code>pointer</code>).</li>
        <li>باستخدام معامل فك الإشارة (<code>dereference operator *</code>)، يمكن للدالة الوصول مباشرة إلى القيمة الموجودة في العنوان وتعديلها، وبالتالي <strong>تؤثر</strong> التغييرات على المتغيرات الأصلية.</li>
    </ul>
    <div class="note">
        <strong>نقطة مهمة للامتحان:</strong> المؤشرات تسمح "بمحاكاة" إرجاع أكثر من قيمة من الدالة أو تغيير قيم المتغيرات الأصلية التي تم تمريرها.
    </div>
    <pre><code>// مثال على Call by Address لدالة swap
void swap(int* x, int* y) { // x and y are pointers, holding addresses
    int temp = *x;         // temp gets the value at the address x points to
    *x = *y;               // The value at address x now gets the value at address y
    *y = temp;             // The value at address y now gets the value from temp
}

int main() {
    int a = 3;
    int b = 4;
    swap(&a, &b); // Pass addresses of a and b using '&'
    // After swap, a will be 4 and b will be 3
    return 0;
}</code></pre>

    <h4>3. المؤشرات (Pointers) والمصفوفات (Arrays)</h4>
    <h5>اسم المصفوفة (Array Name)</h5>
    <div class="note">
        <strong>نقطة مهمة للامتحان:</strong> اسم المصفوفة هو عنوان (<code>address</code>) أول عنصر فيها.
        <br><strong>المحاضر يؤكد بشكل قاطع:</strong> اسم المصفوفة <strong>ليس</strong> مؤشرًا (<code>pointer</code>) وليس مؤشرًا ثابتًا (<code>constant pointer</code>)، وليس له مكان خاص به في الذاكرة كمتغير مؤشر. هذا فرق جوهري يجب الانتباه إليه.
        <br>لا يمكن إجراء عمليات مثل <code>array_name++</code> أو <code>other_array = array_name</code> لأن اسم المصفوفة ثابت ويمثل العنوان الأساسي لها.
    </div>

    <h5>الوصول لعناصر المصفوفة باستخدام المؤشرات</h5>
    <ul>
        <li>يمكن التعامل مع المصفوفات باستخدام تعبيرات (<code>notation</code>) المؤشرات.</li>
        <li><code>arr[i]</code> تكافئ داخليًا <code>*(arr + i)</code>.</li>
        <li>وبالمثل، إذا كان <code>ptr</code> يشير إلى بداية مصفوفة، فإن <code>ptr[i]</code> تكافئ <code>*(ptr + i)</code>.</li>
    </ul>

    <h5>اختيار التعامل مع المؤشرات أو Array Indexing</h5>
    <ul>
        <li>إذا كنت ستتحرك على المصفوفة بشكل <strong>متسلسل</strong> (<code>sequential</code>) من أولها لآخرها (مثل <code>for loop</code>)، يفضل استخدام <strong>حساب المؤشر (pointer arithmetic)</strong> (مثل <code>*ptr++</code> أو <code>*(ptr + i)</code>). هذا يكون أفضل من حيث الأداء (<code>Performance</code>) لأن <code>array[i]</code> تتطلب حساب العنوان في كل مرة.</li>
        <li>إذا كنت ستتحرك على المصفوفة بشكل <strong>عشوائي</strong> (<code>random</code>) (مثل الوصول للعنصر الخامس ثم السابع ثم الأول)، يفضل استخدام <strong>فهرسة المصفوفة (array indexing)</strong> (مثل <code>arr[i]</code>).</li>
    </ul>

    <h4>4. مصفوفة من المؤشرات (Array of Pointers) ومؤشر لمؤشر (Pointer to Pointer)</h4>
    <p>يمكنك تعريف مصفوفة (<code>array</code>) يكون كل عنصر فيها مؤشرًا (<code>pointer</code>). هذا يتيح لك أن يكون لديك مجموعة من المؤشرات، كل منها يشير إلى مكان مختلف في الذاكرة (سواء متغير عادي أو مصفوفة أخرى). هذا يعطي "تأثير" (effect) مصفوفة ثنائية الأبعاد (2D array) ولكن بمرونة أكبر.</p>

    <h4>5. تخصيص الذاكرة الديناميكي (Dynamic Memory Allocation)</h4>
    <h5>أقسام الذاكرة (Memory Segments)</h5>
    <p>الذاكرة مقسمة إلى أجزاء رئيسية، أهمها في هذا السياق: <strong>Stack</strong> و <strong>Heap</strong>.</p>
    <ul>
        <li><strong>Stack:</strong> جزء صغير وسريع من الذاكرة، يُستخدم لتخزين المتغيرات المحلية (<code>local variables</code>) ومكالمات الدوال. عند انتهاء الدالة، يتم مسح متغيراتها من الـ <code>Stack</code> تلقائيًا. إذا امتلأ، يحدث <code>Stack Overflow</code>.</li>
        <li><strong>Heap:</strong> جزء أكبر بكثير من الذاكرة، تُستخدم لتخصيص الذاكرة ديناميكيًا (أثناء وقت التشغيل). الذاكرة المحجوزة في الـ <code>Heap</code> لا يتم مسحها تلقائيًا.</li>
    </ul>

    <h5>التخصيص الديناميكي (Dynamic Allocation)</h5>
    <ul>
        <li>يعني حجز الذاكرة أثناء وقت تشغيل البرنامج (<code>Run Time</code>).</li>
        <li>يتم باستخدام كلمة المفتاح <code>new</code>.</li>
        <li><strong>نقطة مهمة:</strong> عندما تحجز ذاكرة باستخدام <code>new</code>، فإن <code>new</code> يرجع <strong>عنوان</strong> المكان الذي تم حجزه في الـ <code>Heap</code>. لذلك، يجب عليك دائمًا استخدام مؤشر (<code>pointer</code>) لتخزين هذا العنوان.</li>
    </ul>

    <h5>تحرير الذاكرة (Deallocation)</h5>
    <ul>
        <li>يتم باستخدام كلمة المفتاح <code>delete</code>.</li>
        <li class="warning"><strong>نقطة مهمة للامتحان:</strong> يجب دائمًا تحرير الذاكرة التي تم حجزها باستخدام <code>new</code> بعد الانتهاء منها، وذلك باستخدام <code>delete</code>، لتجنب تسرب الذاكرة (<code>Memory Leaks</code>). للتعامل مع مصفوفة ديناميكية، استخدم <code>delete[]</code>.</li>
        <li class="warning"><strong>نقطة مهمة للامتحان:</strong> لا يمكنك <code>delete</code> ذاكرة لم يتم حجزها بـ <code>new</code>، ولا يمكنك <code>delete</code> نفس الذاكرة مرتين. القيام بذلك سيؤدي إلى تعطل البرنامج (<code>program crash</code>).</li>
    </ul>

    <h5>مثال على تخصيص مصفوفة ديناميكيًا (Dynamic-Sized Array Effect)</h5>
    <p>يمكنك تخصيص مصفوفة ديناميكيًا بحجم يحدده المستخدم في وقت التشغيل. هذا يعطي تأثير مصفوفة ذات حجم ديناميكي. المحاضر يشدد على أنه ليس مصفوفة فعلية بمعنى الكلمة، لأن المصفوفات الفعلية يجب أن يكون حجمها ثابتًا ومعروفًا وقت الـ <code>compile</code>.</p>
    <pre><code>#include &lt;iostream&gt;

int main() {
    int size;
    float *ptr; // Step 1: Declare a pointer
    float *ptr1; // To keep track of the original address for deletion

    std::cout &lt;&lt; "Enter array size: ";
    std::cin &gt;&gt; size;

    // Step 2: Allocate memory for 'size' number of floats in the heap
    ptr = new float[size];

    // Step 3: Check if allocation was successful
    if (ptr != NULL) {
        ptr1 = ptr; // Keep the original address for deletion

        // Read values into the dynamic array
        for (int i = 0; i &lt; size; ++i) {
            std::cout &lt;&lt; "Enter element " &lt;&lt; i + 1 &lt;&lt; ": ";
            std::cin &gt;&gt; *ptr;
            ptr++; // Move ptr to the next element
        }

        ptr = ptr1; // Reset ptr to the beginning for processing

        // Sum the elements
        float sum = 0.0;
        for (int i = 0; i &lt; size; ++i) {
            sum += *ptr;
            ptr++;
        }
        std::cout &lt;&lt; "Total sum = " &lt;&lt; sum &lt;&lt; std::endl;

        // Step 4: Deallocate the memory when no longer needed
        delete[] ptr1; // Use delete[] for arrays
    } else {
        std::cout &lt;&lt; "Memory allocation failed!" &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>

    <h4>ملخص فوائد المؤشرات (Pointers Benefits)</h4>
    <p>المحاضر لخص فوائد المؤشرات في ثلاث نقاط رئيسية:</p>
    <ol>
        <li><strong>Call by Address (استدعاء بالعنوان):</strong> يسمح بتغيير القيم الأصلية للمتغيرات التي يتم تمريرها للدوال.</li>
        <li><strong>Dynamic Memory Allocation (تخصيص الذاكرة الديناميكي):</strong>
            <ul>
                <li><strong>يحافظ على مساحة الستاك (Saves Stack Storage):</strong> يسمح بحجز مساحات كبيرة من الذاكرة في الـ <code>Heap</code> بدلاً من الـ <code>Stack</code>.</li>
                <li><strong>يعطي تأثير المصفوفات ذات الحجم الديناميكي (Has the Effect of Arrays with Dynamic Size):</strong> يمكن حجز مصفوفات بحجم غير معروف مسبقًا.</li>
            </ul>
        </li>
    </ol>
</div>
</body>
</html>