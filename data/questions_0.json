[
  {
    "id": 1,
    "question": "When the compiler cannot differentiate between two overloaded functions, it is called",
    "options": [
      {
        "id": "A",
        "text": "Overloaded."
      },
      {
        "id": "B",
        "text": "Destructed."
      },
      {
        "id": "C",
        "text": "Overridden."
      },
      {
        "id": "D",
        "text": "Ambiguous."
      }
    ],
    "correct_answer": "D",
    "explanation": "```arabic\nØ§Ù„Ø³Ø¨Ø¨ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± \"Ambiguous\" Ù‡Ùˆ Ø£Ù†Ù‘Ù‡ Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø¯Ø§Ù„ØªØ§Ù† Ù…ØªØ´Ø§Ø¨Ù‡ØªØ§Ù† ÙÙŠ Ø§Ù„ØªÙˆÙ‚ÙŠØ¹ (signature)ØŒ ÙˆÙ„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„Ù…ØªØ±Ø¬Ù… (compiler) Ø§Ù„ØªÙ…ÙŠÙŠØ² Ø¨ÙŠÙ†Ù‡Ù…Ø§ØŒ ÙŠØ­Ø¯Ø« Ø§Ù„ØªØ¨Ø§Ø³ Ø£Ùˆ \"ambiguity\".\n\nÙ‡Ø°Ø§ ÙŠØ¬Ø¹Ù„ Ø§Ù„Ù…ØªØ±Ø¬Ù… ÙŠØµØ¯Ø± Ø®Ø·Ø£ Ù„Ø¹Ø¯Ù… Ù‚Ø¯Ø±ØªÙ‡ Ø¹Ù„Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠ ÙˆØ§Ø­Ø¯Ø© Ù…Ù†Ù‡Ù…Ø§ ÙŠØ¬Ø¨ Ø£Ù† ØªÙÙ†ÙÙ‘Ø°.\n\n\n\n\n\n\n\n\n\n```",
    "page": 0,
    "updated_at": "2025-08-16T21:57:24.497430"
  },
  {
    "id": 2,
    "question": "The Instance (non-static) variable",
    "options": [
      {
        "id": "A",
        "text": "It is a variable declared in the private section and can be accessed by any method in the same class"
      },
      {
        "id": "B",
        "text": "It is a variable declared in any section in a class and can be accessed by any method in the same class."
      },
      {
        "id": "C",
        "text": "It is a variable declared inside any function and can be accessed by any other methods in the same class"
      },
      {
        "id": "D",
        "text": "It is a variable declared inside any function and cannot be accessed by any other methods in the same class"
      }
    ],
    "correct_answer": "B",
    "explanation": "```arabic\n\n\nØ§Ù„Ù€ instance variable Ù‡Ùˆ Ù…ØªØºÙŠØ± Ø¨ÙŠØªÙ… ØªØ¹Ø±ÙŠÙÙ‡ Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙ„Ø§Ø³ØŒ ÙˆÙ…Ù…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„ÙŠÙ‡ Ù…Ù† Ø£ÙŠ Ù…ÙŠØ«ÙˆØ¯ Ø¯Ø§Ø®Ù„ Ù†ÙØ³ Ø§Ù„ÙƒÙ„Ø§Ø³ØŒ Ø³ÙˆØ§Ø¡ ÙƒØ§Ù†Øª Ø§Ù„Ù€ private Ø£Ùˆ public Ø£Ùˆ protected.\n\n\n\n\n\n\n\n\n\n```",
    "page": 0,
    "updated_at": "2025-08-11T00:13:01.318676"
  },
  {
    "id": 3,
    "question": "If you design a class that needs special initialization tasks, you will have to create a(n):",
    "options": [
      {
        "id": "A",
        "text": "Setter method."
      },
      {
        "id": "B",
        "text": "Initializer Method."
      },
      {
        "id": "C",
        "text": "Constructor."
      },
      {
        "id": "D",
        "text": "Destructor."
      }
    ],
    "correct_answer": "C",
    "explanation": "```arabic\n\nØ§Ù„Ù€ Constructor Ù‡Ùˆ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¹Ù„Ø´Ø§Ù† ÙŠØ¹Ù…Ù„ ØªÙ‡ÙŠØ¦Ø© Ø®Ø§ØµØ© Ù„Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ù„Ù…Ø§ ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§. Ù‡Ùˆ Ø¨ÙŠÙƒÙˆÙ† Ø¹Ø§Ø¯Ø©Ù‹ Ù†ÙØ³ Ø§Ø³Ù… Ø§Ù„ÙƒÙ„Ø§Ø³ ÙˆØ¨ÙŠØ´ØªØºÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù†.\n\n\n\n\n\n\n\n```",
    "page": 0,
    "updated_at": "2025-08-11T00:13:43.953853"
  },
  {
    "id": 4,
    "question": "What will be the output of the following C code2?\n```cpp\n#include <stdio.h>\nint main()\n{\n    int y = 10000;\n    int y = 34;\n    printf(\"Hello World! %d\\n\", y);\n    return 0;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Compile time error"
      },
      {
        "id": "B",
        "text": "Hello World! 34"
      },
      {
        "id": "C",
        "text": "Hello World! 1000"
      },
      {
        "id": "D",
        "text": "Hello World! followed by a junk value"
      }
    ],
    "correct_answer": "A",
    "explanation": "```arabic\n\nØ§Ù„Ø³Ø¨Ø¨ Ù‡Ùˆ Ø¥Ù†Ùƒ Ù…Ø´ Ù‚Ø§Ø¯Ø± ØªØ¹Ù„Ù† Ø¹Ù† Ù†ÙØ³ Ø§Ù„Ù…ØªØºÙŠØ± (y) Ù…Ø±ØªÙŠÙ† ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù†Ø·Ø§Ù‚ (scope). Ø¯Ù‡ Ù‡ÙŠØ¹Ù…Ù„ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© (compile time error) Ù„Ø£Ù†Ùƒ Ø¨ØªØ­Ø§ÙˆÙ„ ØªØ¹Ù„Ù† Ø¹Ù† Ù…ØªØºÙŠØ± Ø¨Ù†ÙØ³ Ø§Ù„Ø§Ø³Ù… Ù…Ø±ØªÙŠÙ†.\n\n\n\n\n\n```",
    "page": 0,
    "updated_at": "2025-08-11T00:15:06.920216"
  },
  {
    "id": 5,
    "question": "The best description for the association relation among the classes",
    "options": [
      {
        "id": "A",
        "text": "When a class using object(s) from other class(es)."
      },
      {
        "id": "B",
        "text": "Objects that are declared using the default constructor."
      },
      {
        "id": "C",
        "text": "An object from a class that is inherited from another class"
      },
      {
        "id": "D",
        "text": "b and c"
      }
    ],
    "correct_answer": "A",
    "explanation": "```arabic\nØ§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„Ù€ Association Ø¨ÙŠÙ† Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øª Ø¨ØªÙƒÙˆÙ† Ù„Ù…Ø§ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„ÙˆØ§Ø­Ø¯ ÙŠØ³ØªØ®Ø¯Ù… ÙƒØ§Ø¦Ù†Ø§Øª (objects) Ù…Ù† ÙƒÙ„Ø§Ø³ ØªØ§Ù†ÙŠ. Ø¯Ù‡ Ø¨ÙŠØ¹Ù†ÙŠ Ø¥Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ Ø¯Ù‡ Ø¨ÙŠØ­ØªØ§Ø¬ ÙŠØ³ØªØ®Ø¯Ù… Ø®ØµØ§Ø¦Øµ Ø£Ùˆ Ù…ÙŠØ«ÙˆØ¯Ø§Øª Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øª Ø§Ù„ØªØ§Ù†ÙŠØ© Ø¹Ù„Ø´Ø§Ù† ÙŠÙƒÙ…Ù„ Ø´ØºÙ„Ù‡.\n\n\n```",
    "page": 0,
    "updated_at": "2025-08-11T00:16:31.912519"
  },
  {
    "id": 6,
    "question": "What will be the output of the following C code? Hint: signed char range is (-128.....127)\n```cpp \n#include <stdio.h>\nint main()\n{\n    signed char chr;\n    chr = 128;\n    printf(\"%d\\n\", chr);\n    return 0;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "128"
      },
      {
        "id": "B",
        "text": "-128"
      },
      {
        "id": "C",
        "text": "Depends on the compiler"
      },
      {
        "id": "D",
        "text": "None of the mentioned"
      }
    ],
    "correct_answer": "B",
    "explanation": "```arabic\nÙ„Ø£Ù† ÙÙŠ CØŒ Ø§Ù„Ù€ signed char Ø¨ÙŠØªØ±Ø§ÙˆØ­ Ù…Ù† -128 Ù„Ù€ 127. Ù„Ù…Ø§ Ø¨ØªØ¯ÙŠÙ„Ù‡ Ù‚ÙŠÙ…Ø© 128ØŒ Ø¨ÙŠØ­ØµÙ„ overflow ÙˆØ¨ÙŠÙ„Ù Ù„Ù€ -128.\n\n\n\n\n\n\n\n```\n\nAssigning 128 to a `signed char` (which has a max value of 127) causes an overflow. On most systems using two's complement representation, this value wraps around to the minimum value, which is -128. Note that signed integer overflow is technically undefined behavior in C.\n\n\n",
    "page": 0,
    "updated_at": "2025-08-11T00:20:02.339608"
  },
  {
    "id": 7,
    "question": "Which of the following refers to \"Hiding data behind class methods?\"",
    "options": [
      {
        "id": "A",
        "text": "Abstraction."
      },
      {
        "id": "B",
        "text": "Encapsulation"
      },
      {
        "id": "C",
        "text": "Polymorphism"
      },
      {
        "id": "D",
        "text": "Inheritance"
      }
    ],
    "correct_answer": "B",
    "explanation": "```arabic\n\n\nÙ„Ø£Ù† Ø§Ù„Ù€ Encapsulation ÙÙŠ Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© ÙŠØ¹Ù†ÙŠ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (data) Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙ„Ø§Ø³ ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ methods Ù„Ù„ÙˆØµÙˆÙ„ Ù„ÙŠÙ‡Ø§ Ø£Ùˆ ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§.\n\n\n\n\n\n\n```\n\nEncapsulation refers to \"hiding data behind class methods.\"\nEncapsulation is the object-oriented programming principle that involves bundling data (attributes) and the methods that operate on that data together within a class, while restricting direct access to the internal data. Instead of allowing external code to directly access or modify an object's data, encapsulation requires interaction through controlled interfaces (methods), which can validate input, maintain data integrity, and hide implementation details.\nThe other concepts serve different purposes:\n\nAbstraction focuses on hiding complexity and showing only essential features\n",
    "page": 0,
    "updated_at": "2025-08-11T00:24:05.090042"
  },
  {
    "id": 8,
    "question": "consider the following code:\n```cpp\nclass Base\n{\npublic:\n    int x;\n    Base(int y)\n    {\n        x=y;\n        ++x;\n    }\n};\n\nclass child : public Base\n{\npublic:\n    child(int c)\n    {\n        x+=1;\n    }\n    void print()\n    {\n        cout<<\"x=\"<<x;\n    }\n};\n\nvoid main()\n{\n    child c(1);\n    c.print();\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "a. x=1"
      },
      {
        "id": "B",
        "text": "b. x=2"
      },
      {
        "id": "C",
        "text": "c. x=3"
      },
      {
        "id": "D",
        "text": "d. x=4"
      },
      {
        "id": "E",
        "text": "e. Compilation Error."
      }
    ],
    "correct_answer": "E",
    "explanation": "```arabic\n\n\nØ§Ù„Ø®Ø·Ø£ Ø§Ù„Ù„ÙŠ Ø¸Ù‡Ø± Ø¨ÙŠÙ‚ÙˆÙ„ Ø¥Ù† Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Base() ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ØŒ ÙˆØ¯Ù‡ Ù„Ø£Ù†Ùƒ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù…Ø¹Ø±ÙØªØ´ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø¨Ø¯ÙˆÙ† Ø¨Ø§Ø±Ø§Ù…ØªØ± ÙÙŠ Ø§Ù„ÙƒÙ„Ø§Ø³ Base.\n\nÙ„Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø¯ÙŠØŒ Ù„Ø§Ø²Ù… ØªØ¶ÙŠÙ ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ø£Ùˆ ÙƒÙˆÙ†Ø³ÙˆØªØ± ÙØ§Ø±Øº) ÙÙŠ Ø§Ù„ÙƒÙ„Ø§Ø³ Base Ù„Ùˆ ÙƒÙ†Øª Ø¹Ø§ÙŠØ² ØªÙ†Ø´Ø¦ ÙƒØ§Ø¦Ù†Ø§Øª Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ Base Ø¨Ø¯ÙˆÙ† ØªÙ…Ø±ÙŠØ± Ø¨Ø§Ø±Ø§Ù…ØªØ±. Ù„ÙƒÙ† ÙÙŠ Ø­Ø§Ù„ØªÙƒØŒ Ø¨Ù…Ø§ Ø£Ù†Ùƒ Ø¨ØªØ³ØªØ®Ø¯Ù… ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø¨ÙŠØªØ·Ù„Ø¨ Ø¨Ø§Ø±Ø§Ù…ØªØ±ØŒ Ù‡Ù†Ø­ØªØ§Ø¬ Ù†Ø¹Ø¯Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø­ÙŠØ« Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù„ÙŠ Ø¨ØªÙ†Ø´Ø£ Ù…Ù† Child Ù„Ø§Ø²Ù… ØªÙƒÙˆÙ† Ø¨ØªØ³ØªØ¯Ø¹ÙŠ ÙƒÙˆÙ†Ø³ÙˆØªØ± Base Ù…Ø¹ Ø¨Ø§Ø±Ø§Ù…ØªØ±.\n\n\n\n\n```\n```img\nhttps://i.ibb.co/Xr9g7jhk/image.png\n```\n\n```arabic\nØ§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª:\nØ§Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ± ÙÙŠ Base Ø¨ÙŠØ³ØªÙ‚Ø¨Ù„ Ø¨Ø§Ø±Ø§Ù…ØªØ±ØŒ ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù„Ùˆ Ø¹Ø§ÙŠØ² ØªÙ†Ø´Ø¦ ÙƒØ§Ø¦Ù† Ù…Ù† Child Ù„Ø§Ø²Ù… ØªÙ…Ø±Ø± Ù‚ÙŠÙ…Ø© Ù„Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ±.\n\nÙÙŠ ChildØŒ Ø§Ø³ØªØ®Ø¯Ù…Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø© (initializer list) Ø¹Ù„Ø´Ø§Ù† ØªØ³ØªØ¯Ø¹ÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø¨ØªØ§Ø¹ Base Ø¨Ø§Ù„Ø¨Ø§Ø±Ø§Ù…ØªØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.\n```\n\n```cpp\n\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\nprotected:\n    int x;  \npublic:\n    // Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø¨ÙŠØ³ØªÙ‚Ø¨Ù„ Ø¨Ø§Ø±Ø§Ù…ØªØ±\n    Base(int y)\n    {\n        x = y;\n        ++x;\n    }\n};\n\nclass Child : public Base\n{\npublic:\n    // Ù‡Ù†Ø§ Ø¨Ù†Ø³ØªØ¯Ø¹ÙŠ ÙƒÙˆÙ†Ø³ÙˆØªØ± Base Ù…Ø¹ ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚ÙŠÙ…Ø© c\n    Child(int c) : Base(c)  \n    {\n        x += 1;\n    }\n\n    void print()\n    {\n        cout << \"x=\" << x;  \n    }\n};\n\nint main()\n{\n    Child c(1);  \n    c.print();   \n\n    return 0;\n}\n\n```\n\n\n// output is : x=3\n\n\n\n\nÙ„Ø§Ø­Ø¸ Ø§Ø®ØªÙ„Ø§Ù Ø§Ù„ØªÙ†ÙÙŠØ°\nØ§Ù„ base first\nØ¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† ØªÙ…Ø±ÙŠØ± Ù‚ÙŠÙ…Ø© 1\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\nprotected:\n    int x;  \npublic:\n    // Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆØªØ± Ø¨ÙŠØ³ØªÙ‚Ø¨Ù„ Ø¨Ø§Ø±Ø§Ù…ØªØ±\n    Base(int y)\n    {\n           cout << \"Base1\" << endl;\n        x = y;\n        ++x;\n    }\n};\n\nclass Child : public Base\n{\npublic:\n    // Ù‡Ù†Ø§ Ø¨Ù†Ø³ØªØ¯Ø¹ÙŠ ÙƒÙˆÙ†Ø³ÙˆØªØ± Base Ù…Ø¹ ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚ÙŠÙ…Ø© c\n    Child(int c) : Base(c)  \n    {\n        x += 1;\n           cout << \"child2\" << endl;\n    }\n\n    void print()\n    {\n        cout << \"x=\" << x;  \n     \n    }\n};\n\nint main()\n{\n    Child c(1);  \n    c.print();   \n\n    return 0;\n}\n```\n\noutput is:\n```cpp\nBase1\nchild2\nx=3\n```",
    "page": 0,
    "updated_at": "2025-08-20T19:33:36.552906"
  },
  {
    "id": 9,
    "question": "What will be the output when you compile and run the following piece of code?\nin cpp\n```cpp\nint sum(int a, int b) { return a+b;}\nfloat sum(float a, float b) { return a+b;}\nvoid main(void)\n{\n   // clrscr();\n    cout<<\"sum =\"<<sum(5,9)<<\"\\t\";\n    cout<<\"sum =\"<<sum(4.3,2.7);\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "a. sum = 14 sum = 7.0"
      },
      {
        "id": "B",
        "text": "b. Compiler Error: add() function should be overloaded"
      },
      {
        "id": "C",
        "text": "c. Compiler Error: Ambiguity between 'sum (int, int)' and 'sum (float, float)'"
      },
      {
        "id": "D",
        "text": "d. sum = 14 sum = 6"
      }
    ],
    "correct_answer": "C",
    "explanation": "```img\nhttps://i.ibb.co/ynGbbm5X/image.png\n```\nØ§Ù„Ø­Ù„ Ù„Ùˆ Ø¹Ø§ÙŠØ² Ø§Ù„ÙƒÙˆØ¯ ÙŠØ´ØªØºÙ„:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint sum(int a, int b) { return a + b; }\nfloat sum(float a, float b) { return a + b; }\n\nint main()\n{\n    // clrscr();  // Ù…ØªØ³ØªØ®Ø¯Ù…Ù‡Ø§Ø´ ÙÙŠ GCC\n    cout << \"sum = \" << sum(5, 9) << \"\\t\";\n    cout << \"sum = \" << sum(4.3f, 2.7f); // Ø§Ø³ØªØ®Ø¯Ù… 'f' Ø¹Ù„Ø´Ø§Ù† ØªÙ‚ÙˆÙ„ Ù„Ù‡ Ø¥Ù†Ù‡Ø§ float\n    return 0;\n}\n```\nØ§Ù„Ù†Ø§ØªØ¬ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„:\n```cpp\nsum = 14    sum = 7\n```\nâœ… ÙÙ€ Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ:\n```arabic\n\nØ§Ù„Ø³Ø¨Ø¨ ÙÙŠ Ø§Ù„Ù„Ø¨Ø³ Ø§Ù„Ø°ÙŠ ÙŠØ­Ø¯Ø« Ù„Ù„Ù…ØªØ±Ø¬Ù… (compiler) Ù‡Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… `double`.\n\nØ£Ù…Ø§ `clrscr`ØŒ ÙÙ‡ÙŠ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©.\n```",
    "page": 0,
    "updated_at": "2025-08-18T11:30:22.385925"
  },
  {
    "id": 10,
    "question": "what will be the output when you compile the following piece of code?\n```cpp\nclass Test\n{\n    int x;\npublic:\n    float z;\n    int y;\n};\nvoid main()\n{\n    Test t1;\n    t1.x = 100;\n    t1.y = 500;\n    t1.z = 250.43;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "a. Compiler Error regarding the variable x."
      },
      {
        "id": "B",
        "text": "b. Compiler Error regarding the variable y."
      },
      {
        "id": "C",
        "text": "c. Compiler Error regarding the variable z."
      },
      {
        "id": "D",
        "text": "d. The code will compile successfully."
      }
    ],
    "correct_answer": [
      "A"
    ],
    "explanation": "```img\nhttps://i.ibb.co/nNLzMDMy/image.png\n```\n\nIn a C++ class, members are `private` by default. Since `int x;` is declared before any access specifier, it is a private member of `Test`. The `main` function is outside the class and cannot access private members, so the line `t1.x = 100;` will cause a compilation error.",
    "page": 0,
    "updated_at": "2025-08-16T22:01:25.084453"
  },
  {
    "id": 11,
    "question": "what will be the output when you compile and run the following piece of code?\n```cpp\nclass Test\n{\npublic:\n    virtual void say() { cout<<\"Test\\t\"; }\n};\nclass NewTest : public Test\n{\npublic:\n    void say() { cout<<\"NewTest\\t\"; }\n};\nvoid main()\n{\n    Test *pb;\n    Test myParent;\n    NewTest myChild;\n\n    pb = &myParent;\n    pb->say();\n    pb = &myChild;\n    pb->say();\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Test    NewTest"
      },
      {
        "id": "B",
        "text": "b. Test    Test"
      },
      {
        "id": "C",
        "text": "c. NewTest    NewTest"
      },
      {
        "id": "D",
        "text": "d. NewTest    Test"
      }
    ],
    "correct_answer": "A",
    "explanation": "```img\nhttps://i.ibb.co/4k7wwYw/image.png\n```\n```arabic\nØ§ÙŠÙ‡ Ù‡ÙŠØ­ØµÙ„ Ù„Ùˆ Ù…ÙÙŠØ´\nvirtual\nØ§Ù„Ù†Ø§ØªØ¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: Test Test âŒ\n\nÙ„Ø£Ù† Ø§Ù„Ù€ binding Ù‡ÙŠØ¨Ù‚Ù‰ staticØŒ ÙˆØ§Ù„Ù€ pb Ù…Ù† Ù†ÙˆØ¹ Test*ØŒ ÙØ­ØªÙ‰ Ù„Ùˆ Ø£Ø´Ø§Ø± Ù„Ù€ NewTestØŒ Ù‡ÙŠØ³ØªØ®Ø¯Ù… say() Ø¨ØªØ§Ø¹Ø© Test.\n\n\nÙŠØ¹Ù†ÙŠ Ù…Ù† ØºÙŠØ± virtualØŒ Ø§Ù„Ù€ override Ù…Ø´ Ù‡ÙŠØ´ØªØºÙ„ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ù€ pointer.\n```\n```cpp\n\n#include <iostream>\nusing namespace std;\n\n// Ø¨Ø¯ÙˆÙ† virtual\nclass Test {\npublic:\n    void say() { cout << \"Test\\t\"; }  // Ø¨Ø¯ÙˆÙ† virtual\n};\n\nclass NewTest : public Test {\npublic:\n    void say() { cout << \"NewTest\\t\"; }\n};\n\nint main() {\n    Test *pb;\n    Test myParent;\n    NewTest myChild;\n\n    pb = &myParent;\n    pb->say();  // Test\n\n    pb = &myChild;\n    pb->say();  // !! Ù‡ÙŠØ·Ø¨Ø¹ \"Test\" Ù…Ø´ \"NewTest\" !!\n\n    return 0;\n}\n```\n\n\n\n\nØ­Ù„ Ø§Ø®Ø± Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… \nPointers\n```cpp\n#include <iostream>\n\nusing namespace std;\n\n\nclass Test\n{\npublic:\n    virtual void say() { cout<<\"Test\\t\"; }\n};\nclass NewTest : public Test\n{\npublic:\n    void say() { cout<<\"NewTest\\t\"; }\n};\nint main()\n{\n    Test aa;\n\n    NewTest myChild;\n\n    aa.say();\n    myChild.say();\n}\n```\n\n\n\nØ­Ù„ Ø§Ø®Ø± Ø¨Ø¯ÙˆÙ† Virtual\nÙˆÙ„ÙƒÙ† Pointer\n```cpp\n#include <iostream>\n\nusing namespace std;\n\n\nclass Test\n{\npublic:\n    virtual void say() { cout<<\"Test\\t\"; }\n};\nclass NewTest : public Test\n{\npublic:\n    void say() { cout<<\"NewTest\\t\"; }\n};\nint main()\n{\n    Test bb;\n    Test* pbb = &bb;\n    pbb->say();\n\n    NewTest cc;\n    NewTest* pcc = &cc;\n    pcc->say();\n\n\n\n    return 0;\n}\n```",
    "page": 0,
    "updated_at": "2025-08-20T19:21:30.078200"
  },
  {
    "id": 12,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Base\n{\npublic:\n    Base() { cout<<\"Welcome\"<<\"\\t\"; }\n};\nclass Derived: public Base\n{\npublic:\n    Derived() { cout<<\"Hello\"<<\"\\t\"; }\n};\nvoid main()\n{\n    Derived myD;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "a. Hello"
      },
      {
        "id": "B",
        "text": "b. Hello Welcome"
      },
      {
        "id": "C",
        "text": "c. Welcome Hello"
      },
      {
        "id": "D",
        "text": "d. Welcome"
      }
    ],
    "correct_answer": "C",
    "explanation": "```img\nhttps://i.ibb.co/GQJdmmwd/image.png\n```\nWhen an object of a derived class is created, the constructor of the base class is always executed first, followed by the constructor of the derived class. Therefore, `Base()` runs, printing 'Welcome', and then `Derived()` runs, printing 'Hello'.",
    "page": 0,
    "updated_at": "2025-08-11T01:33:51.033118"
  },
  {
    "id": 13,
    "question": "what does the following piece of code do?\n```cpp\nvoid main()\n{\n    float *ptr;\n    ptr = new float(15);\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "a. Allocate space for 15 float contiguous variables that are initialized by 0."
      },
      {
        "id": "B",
        "text": "b. Allocate space for 15 float contiguous variables that are not initialized"
      },
      {
        "id": "C",
        "text": "c. Allocate space for a float variable that is initialized by the value 15."
      },
      {
        "id": "D",
        "text": "d. Allocate space for a float variable that is not initialized."
      }
    ],
    "correct_answer": "C",
    "explanation": "```img\nhttps://i.ibb.co/jkCS2yYH/image.png\n```\n```arabic\nâ€«float *ptr; Ø¨ÙŠØ¹Ø±Ù‘Ù pointer Ù…Ù† Ù†ÙˆØ¹ float.â€¬\nâ€«ptr = new float(15); Ø¨ÙŠØ¹Ù…Ù„ allocate Ù„Ù…ÙƒØ§Ù† ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„Ù€ float ÙˆØ§Ø­Ø¯ Ø¨Ø³ ÙˆÙŠØ­Ø· ÙÙŠÙ‡ Ø§Ù„Ù‚ÙŠÙ…Ø© 15.â€¬\nâ€«Ù…Ø´ Ø¨ÙŠØ¹Ù…Ù„ array Ø²ÙŠ new float[15]ØŒ ÙˆÙ„Ø§ Ø¨ÙŠØ³ÙŠØ¨ Ø§Ù„Ù…ÙƒØ§Ù† Ù…Ù† ØºÙŠØ± initialize.â€¬\nâ€«Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­: c. ØªØ®ØµÙŠØµ Ù…ÙƒØ§Ù† Ù„Ù…ØªØºÙŠØ± float Ø¨Ù‚ÙŠÙ…Ø© 15.\n```â€¬",
    "page": 0,
    "updated_at": "2025-08-11T01:39:04.142104"
  },
  {
    "id": 14,
    "question": "What does the following piece of code do?\n```cpp\nvoid main()\n{\n    float *ptr;\n    ptr = new float[15];\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Allocate space for a float variable that is not initialized"
      },
      {
        "id": "B",
        "text": "Allocate space for an array of 15 float elements that are not initialized"
      },
      {
        "id": "C",
        "text": "Allocate space for an array of 15 float elements that is initialized by the value 0"
      },
      {
        "id": "D",
        "text": "Allocate space for an array of 15 float elements where all the elements are initialized by the value 15"
      },
      {
        "id": "E",
        "text": "Compiler Error."
      }
    ],
    "correct_answer": "B",
    "explanation": "```arabic\nØ§Ù„ÙƒÙˆØ¯ Ø¨ÙŠØ¹Ù…Ù„ new float[15] ÙŠØ¹Ù†ÙŠ Ø¨ÙŠØ­Ø¬Ø² Ù…ÙƒØ§Ù† ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„Ù€ 15 Ø¹Ù†ØµØ± Ù…Ù† Ù†ÙˆØ¹ float Ù…Ù† ØºÙŠØ± Ù…Ø§ ÙŠØ¹Ø·ÙŠÙ‡Ù… Ù‚ÙŠÙ… Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ© (Ù…Ø´ Ù…Ù‡ÙŠÙ‘ÙØ¦ÙŠÙ†). Ù„Ùˆ Ø¹Ø§ÙŠØ²ÙŠÙ† Ù†ÙÙ‡ÙŠÙ‘ÙØ¦Ù‡Ù… Ø¨ØµÙØ± Ù…Ø«Ù„Ø§Ù‹ØŒ ÙƒÙ†Ø§ Ù„Ø§Ø²Ù… Ù†ÙƒØªØ¨ new float[15]()ØŒ Ù„ÙƒÙ† Ù‡Ù†Ø§ Ù…ÙÙŠØ´ Ø£Ù‚ÙˆØ§Ø³ ÙØ§Ù„Ø¹Ù†Ø§ØµØ± Ø¨ØªÙƒÙˆÙ† Ù‚ÙŠÙ…Ù‡Ø§ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (garbage values).\n```\n```img\nhttps://i.ibb.co/k6WRX0pC/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-11T01:51:33.717736"
  },
  {
    "id": 15,
    "question": "In any abstract class, it has to include:",
    "options": [
      {
        "id": "A",
        "text": "a. At least a member function."
      },
      {
        "id": "B",
        "text": "b. At least a virtual function"
      },
      {
        "id": "C",
        "text": "c. At least a static function."
      },
      {
        "id": "D",
        "text": "d. At least a pure virtual function"
      },
      {
        "id": "E",
        "text": "e. All of the above"
      }
    ],
    "correct_answer": "D",
    "explanation": "By definition in C++, a class is considered abstract if and only if it contains at least one pure virtual function (e.g., `virtual void func() = 0;`). Abstract classes cannot be instantiated.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 16,
    "question": "The body of the destructor of the base class is executed automatically:",
    "options": [
      {
        "id": "A",
        "text": "a. When any member function of the derived class is called."
      },
      {
        "id": "B",
        "text": "b. After the body of the destructor of the derived class is executed."
      },
      {
        "id": "C",
        "text": "c. Before the body of the destructor of the derived class is executed."
      },
      {
        "id": "D",
        "text": "d. We cannot determine exactly when it will be executed."
      }
    ],
    "correct_answer": "B",
    "explanation": "ÙÙŠ C++ØŒ Ù„Ù…Ø§ Ø¨ÙŠØªÙ… ØªØ¯Ù…ÙŠØ± ÙƒØ§Ø¦Ù† Ù…Ù† ÙƒÙ„Ø§Ø³ Ù…Ø´ØªÙ‚ (derived class)ØŒ Ø§Ù„Ù€ destructor Ø¨ØªØ§Ø¹ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ØªÙ‚ Ø¨ÙŠØªÙ†ÙØ° Ø§Ù„Ø£ÙˆÙ„ØŒ ÙˆØ¨Ø¹Ø¯ÙŠÙ† Ø§Ù„Ù€ destructor Ø¨ØªØ§Ø¹ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (base class) Ø¨ÙŠØªÙ†ÙØ° ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§. Ø¯Ù‡ Ø¨ÙŠØ­ØµÙ„ Ø¹Ø´Ø§Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ØªÙ‚ Ø¨ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØŒ ÙØ§Ù„ØªØ¯Ù…ÙŠØ± Ø¨ÙŠØªÙ… Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹ÙƒØ³ÙŠ Ù„Ù„Ø¥Ù†Ø´Ø§Ø¡.\n\nÙ…Ø«Ø§Ù„ Ù„Ù„ØªÙˆØ¶ÙŠØ­\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    ~Base() { cout << \"Base Destructor\" << endl; }\n};\n\nclass Derived : public Base {\npublic:\n    ~Derived() { cout << \"Derived Destructor\" << endl; }\n};\n\nint main() {\n    Derived d;\n    return 0;\n}\n```\nTracing for Execution:\n```img\nhttps://i.ibb.co/tMxY38hh/image.png\n```\nDestruction happens in the reverse order of construction. When a derived class object is destroyed, the derived class's destructor is executed first, followed by the base class's destructor.",
    "page": 0,
    "updated_at": "2025-08-11T02:00:08.820768"
  },
  {
    "id": 17,
    "question": "```cpp\n\"A car is a transportation mean that has a Motor, color and 4 wheels\"\n\"A bicycle is a transportation mean that has a handlebar, color and 2 wheels\"\n```\nWhich of the following best describes the previous statements as a set of classes?",
    "options": [
      {
        "id": "A",
        "text": "a. 2 classes: A car class that has two attributes: color, motor and numberOfWheels, and a bicycle class that also has two attributes: color, handlebar and numberOfWheels."
      },
      {
        "id": "B",
        "text": "b. 3 classes: A Transportation_Mean class that has one attribute: color. A car class that inherits from the Transportation_Mean class and has two attributes: motor and numberOfWheels. And a bicycle class that also inherits from the Transportation_Mean class and has two attributes: handlebar and numberOfWheels."
      },
      {
        "id": "C",
        "text": "c. 1 class: A Transportation_Mean class that has an attribute for the: typeOfTransport."
      },
      {
        "id": "D",
        "text": "d. 3 classes: A Transportation_Mean class that has one attribute: numberOfWheels. A car class that inherits from the Transportation_Mean class and has two attributes: motor and color. And a bicycle class that inherits from the car class and has one attribute: handlebar."
      }
    ],
    "correct_answer": "B",
    "explanation": "```arabic\nØ§Ù„Ø®ÙŠØ§Ø± b Ù‡Ùˆ Ø§Ù„Ø£ÙØ¶Ù„ Ù„Ø£Ù†Ù‡ Ø¨ÙŠØ¹ÙƒØ³ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„ÙˆØ±Ø§Ø«ÙŠØ© ØµØ­: Ø§Ù„Ø¹Ø±Ø¨Ø© ÙˆØ§Ù„Ø¯Ø±Ø§Ø¬Ø© Ø¯ÙˆÙ„ Ù†ÙˆØ¹ÙŠÙ† Ù…Ù† ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„Ù†Ù‚Ù„ (Transportation_Mean)ØŒ ÙØ¨Ù†Ø¹Ù…Ù„ base class Ù„Ù„Ù€ color Ø§Ù„Ù…Ø´ØªØ±ÙƒØŒ ÙˆÙƒÙ„ ÙˆØ§Ø­Ø¯ ÙÙŠÙ‡Ù… ÙŠÙˆØ±Ø« Ù…Ù†Ù‡ ÙˆÙŠØ¶ÙŠÙ Ø®ØµØ§Ø¦ØµÙ‡ Ø§Ù„Ø®Ø§ØµØ© (Ø§Ù„Ø¹Ø±Ø¨Ø© Ù„Ù‡Ø§ motor ÙˆØ§Ù„Ø¯Ø±Ø§Ø¬Ø© Ù„Ù‡Ø§ handlebar). ÙƒÙ…Ø§Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ø¬Ù„Ø§Øª (numberOfWheels) Ù…Ø®ØªÙ„Ù Ø¨ÙŠÙ†Ù‡Ù… ÙÙƒÙ„ class ÙŠØ­Ø¯Ø¯Ù‡ Ø¨Ù†ÙØ³Ù‡.\n```\n```arabic\nØªÙˆØ¶ÙŠØ­ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰:\na: ØºÙ„Ø· Ù„Ø£Ù†Ù‡ Ù…Ø¨ÙŠØ³ØªØ®Ø¯Ù…Ø´ inheritance ÙˆÙ…Ø¨ÙŠØ¹ÙƒØ³Ø´ Ø§Ù„Ø¹Ù„Ø§Ø·Ø© \"is-a\" Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø¬Ù…Ù„.\nc: ØºÙ„Ø· Ù„Ø£Ù†Ù‡ Ø¨ÙŠØ¬Ù…Ø¹ ÙƒÙ„ Ø­Ø§Ø¬Ø© ÙÙŠ class ÙˆØ§Ø­Ø¯ ÙˆÙ…Ø¨ÙŠÙØ±Ù‚Ø´ Ø¨ÙŠÙ† Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¹Ø±Ø¨Ø© ÙˆØ§Ù„Ø¯Ø±Ø§Ø¬Ø©.\nd: ØºÙ„Ø· Ù„Ø£Ù†Ù‡ Ø¨ÙŠØ¬Ø¹Ù„ Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© ØªØ±Ø« Ù…Ù† Ø§Ù„Ø¹Ø±Ø¨Ø©ØŒ ÙˆÙ‡Ø°Ø§ Ù…Ø´ Ù…Ù†Ø·Ù‚ÙŠ (Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ù…Ø´ Ø¹Ø±Ø¨ÙŠØ©!).\n```\n\n\n\nThis scenario is a classic example of inheritance. A base class `Transportation_Mean` can hold common attributes like `color`. `Car` and `Bicycle` are specialized types of transportation, so they should inherit from the base class and add their specific attributes. This promotes code reuse and logical structure.",
    "page": 0,
    "updated_at": "2025-08-16T22:05:21.268570"
  },
  {
    "id": 18,
    "question": "```cpp\n'A plane is a machine that has a motor and has wings'.\n'A refrigerator is a machine that has a motor and has shelves'. \n```\nWhich of the following best describes the previous statements as a set of classes?",
    "options": [
      {
        "id": "A",
        "text": "a) 3 classes: A machine class that has one attribute: motor. A plane class that inherits from the machine class. And a refrigerator class that inherits from the plane class."
      },
      {
        "id": "B",
        "text": "b) 3 classes: A machine class that has one attribute: motor. A plane class that inherits from the machine class. And a refrigerator class that also inherits from the machine class."
      },
      {
        "id": "C",
        "text": "c) 2 classes: A plane class that has two attributes, and a refrigerator class that also has two attributes."
      },
      {
        "id": "D",
        "text": "d) 1 class: A machine class that has an attribute for the type of machine."
      }
    ],
    "correct_answer": "B",
    "explanation": "```img\nhttps://i.ibb.co/wZ8dt90Z/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-16T22:05:51.017570"
  },
  {
    "id": 19,
    "question": "The following are examples of Object-Oriented advantages: (choose all that applies)",
    "options": [
      {
        "id": "A",
        "text": "a. Simplicity"
      },
      {
        "id": "B",
        "text": "b. Reusability"
      },
      {
        "id": "C",
        "text": "c. Encapsulation"
      },
      {
        "id": "D",
        "text": "d. Modularity"
      },
      {
        "id": "E",
        "text": "e. Abstraction"
      }
    ],
    "correct_answer": [
      "A",
      "B",
      "C",
      "D",
      "E"
    ],
    "explanation": "```img\nhttps://i.postimg.cc/sxyXkG18/image.png\n```\nğŸ­ Imagine OOP as a Traditional Egyptian Wedding ğŸ‰\nEach concept is like a role or tradition in the wedding:\n\nğŸ§º Encapsulation = Ø§Ù„Ø¹Ø±ÙˆØ³Ø© Ø§Ù„Ù„ÙŠ Ù…Ø®Ø¨ÙŠØ© Ø­Ø§Ø¬Ø§Øª ÙÙŠ Ø´Ù†Ø·ØªÙ‡Ø§\nØ²ÙŠ Ù…Ø§ Ø§Ù„Ø¹Ø±ÙˆØ³Ø© Ø¨ØªØ®Ø¨ÙŠ Ø­Ø§Ø¬Ø§Øª ÙÙŠ Ø´Ù†Ø·ØªÙ‡Ø§ ÙˆÙ…Ø­Ø¯Ø´ ÙŠØ¹Ø±Ù Ø¥ÙŠÙ‡ Ø§Ù„Ù„ÙŠ Ø¬ÙˆØ§Ù‡Ø§ØŒ Ø§Ù„ÙƒÙ„Ø§Ø³ ÙÙŠ Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© Ø¨ÙŠØ®Ø¨ÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¬ÙˆØ§Ù‡ ÙˆÙ…Ø¨ÙŠØ®Ù„ÙŠØ´ Ø­Ø¯ ÙŠØ¹Ø¨Ø« Ø¨ÙŠÙ‡Ø§ ØºÙŠØ± Ø¨Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„Ù„ÙŠ Ù‡Ùˆ Ù…Ø­Ø¯Ø¯Ù‡Ø§.\n\nTranslation: Just like the bride keeps her stuff private in her handbag, a class hides its internal data and only allows access through defined methods.\n\nğŸ§± Modularity = ÙƒÙ„ ÙˆØ§Ø­Ø¯ Ù„ÙŠÙ‡ Ø´ØºÙ„ØªÙ‡ ÙÙŠ Ø§Ù„ÙØ±Ø­\nÙÙŠ Ø§Ù„ÙØ±Ø­ØŒ ÙÙŠ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØµÙˆØ±ØŒ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ·Ø¨Ø®ØŒ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØºÙ†ÙŠ... ÙƒÙ„ ÙˆØ§Ø­Ø¯ Ù„ÙŠÙ‡ Ø¯ÙˆØ± Ù…Ø³ØªÙ‚Ù„. Ù†ÙØ³ Ø§Ù„ÙƒÙ„Ø§Ù… ÙÙŠ OOPØŒ ÙƒÙ„ ÙƒÙ„Ø§Ø³ Ù„ÙŠÙ‡ ÙˆØ¸ÙŠÙØ© Ù…Ø­Ø¯Ø¯Ø©.\n\nTranslation: Just like each person at the wedding has a specific role, each class in OOP has a distinct responsibility.\n\nğŸ” Reusability = Ø§Ù„Ø·Ø±Ø¨ÙˆØ´ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØªÙ„Ø¨Ø³ ÙÙŠ ÙƒÙ„ Ø§Ù„Ø£ÙØ±Ø§Ø­\nØ§Ù„Ø·Ø±Ø¨ÙˆØ´ Ø¨ÙŠØªÙ„Ø¨Ø³ ÙÙŠ ÙƒÙ„ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø§ØªØŒ Ù…Ø´ Ù„Ø§Ø²Ù… Ù†Ø´ØªØ±ÙŠ ÙˆØ§Ø­Ø¯ Ø¬Ø¯ÙŠØ¯ ÙƒÙ„ Ù…Ø±Ø©. Ø§Ù„ÙƒÙ„Ø§Ø³ ÙƒÙ…Ø§Ù† Ù…Ù…ÙƒÙ† Ù†Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙŠ ÙƒØ°Ø§ Ù…Ø´Ø±ÙˆØ¹ Ù…Ù† ØºÙŠØ± Ù…Ø§ Ù†Ø¹ÙŠØ¯ ÙƒØªØ§Ø¨ØªÙ‡.\n\nTranslation: Like a tarboosh thatâ€™s reused in every celebration, classes can be reused across multiple projects.\n\nğŸ§  Abstraction = Ø§Ù„Ø¹Ø±ÙŠØ³ Ø§Ù„Ù„ÙŠ Ø¨ÙŠÙ‚ÙˆÙ„ \"Ø£Ù†Ø§ Ø¬Ø§Ù‡Ø²\" Ù…Ù† ØºÙŠØ± Ù…Ø§ ÙŠØ´Ø±Ø­ Ø§Ù„ØªÙØ§ØµÙŠÙ„\nØ§Ù„Ø¹Ø±ÙŠØ³ Ø¨ÙŠÙ‚ÙˆÙ„ \"Ø£Ù†Ø§ Ø¬Ø§Ù‡Ø²\" Ø¨Ø³ Ù…Ø­Ø¯Ø´ ÙŠØ¹Ø±Ù Ù‡Ùˆ Ø¹Ù…Ù„ Ø¥ÙŠÙ‡ Ø¹Ù„Ø´Ø§Ù† ÙŠØ¬Ù‡Ø². Ù†ÙØ³ Ø§Ù„ÙÙƒØ±Ø© ÙÙŠ OOPØŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¹Ø±Ù Ø§Ù„ÙˆØ¸ÙŠÙØ© Ø¨Ø³ Ù…Ø´ Ù„Ø§Ø²Ù… ÙŠØ¹Ø±Ù Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©.\n\nTranslation: The groom says â€œIâ€™m readyâ€ without explaining all the behind-the-scenes prep â€” just like abstraction hides the complexity.\n\nğŸ˜Œ Simplicity = Ø§Ù„ÙØ±Ø­ Ø§Ù„Ù„ÙŠ ÙƒÙ„Ù‡ Ù…Ù†Ø¸Ù… ÙˆÙ…ÙÙ‡ÙˆÙ…\nÙ„Ù…Ø§ Ø§Ù„ÙØ±Ø­ ÙŠÙƒÙˆÙ† Ù…Ù†Ø¸Ù…ØŒ Ø§Ù„Ù†Ø§Ø³ Ø¨ØªÙ†Ø¨Ø³Ø· ÙˆÙ…ØªÙÙ‡Ù…Ø´ Ø§Ù„Ø¯Ù†ÙŠØ§ Ù…Ø§Ø´ÙŠØ© Ø¥Ø²Ø§ÙŠ. OOP Ø¨ÙŠØ®Ù„ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù†Ø¸Ù… ÙˆØ³Ù‡Ù„ Ø§Ù„ÙÙ‡Ù….",
    "page": 0,
    "updated_at": "2025-08-16T22:09:41.157238"
  },
  {
    "id": 20,
    "question": "The Embedded object is:",
    "options": [
      {
        "id": "A",
        "text": "a. An object declared with default constructor."
      },
      {
        "id": "B",
        "text": "b. An object has function overloading."
      },
      {
        "id": "C",
        "text": "c. An object from a class inherited from another class."
      },
      {
        "id": "D",
        "text": "d. An object included by another object."
      }
    ],
    "correct_answer": "D",
    "explanation": "An embedded object, representing composition or aggregation, is an object that is a member variable of another class. This models a 'has-a' relationship.\n```cpp\nclass Engine {\n    // Engine details\n};\n\nclass Car {\n    Engine myEngine; // Embedded object\n};\n```\n```img\nhttps://i.postimg.cc/zvBmHqQv/image.png\n```\nğŸ  Embedded Object = Ø§Ù„Ø¹ÙØ´ Ø§Ù„Ù„ÙŠ Ø¬ÙˆÙ‡ Ø§Ù„Ø´Ù‚Ø©\nØªØ®ÙŠÙ„ Ø¥Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ Ù‡Ùˆ Ø´Ù‚Ø©ØŒ ÙˆØ§Ù„Ø¹ÙØ´ Ø§Ù„Ù„ÙŠ Ø¬ÙˆØ§Ù‡Ø§ (ÙƒÙ†Ø¨Ø©ØŒ ØªÙ„ÙØ²ÙŠÙˆÙ†ØŒ ØªÙ„Ø§Ø¬Ø©) Ù‡Ùˆ Ø§Ù„Ù€ embedded objects. ÙŠØ¹Ù†ÙŠ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø¨ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒØ§Ø¦Ù†Ø§Øª ØªØ§Ù†ÙŠØ© Ø¬ÙˆØ§Ù‡ØŒ Ø²ÙŠ Ù…Ø§ Ø§Ù„Ø´Ù‚Ø© Ø¨ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø­Ø§Ø¬Ø§Øª ØªØ§Ù†ÙŠØ© Ø¬ÙˆØ§Ù‡Ø§.\n\nTranslation: Think of a class as an apartment, and the furniture inside (sofa, TV, fridge) are embedded objects. The class contains other objects just like the apartment contains its contents.\n```cpp\nclass Sofa {\n    // Sofa details\n};\n\nclass Apartment {\n    Sofa mySofa; // Embedded object\n};\n```\nHere, mySofa is part of Apartment, just like the sofa is part of the apartmentâ€™s contents.",
    "page": 0,
    "updated_at": "2025-08-16T22:13:05.867491"
  },
  {
    "id": 21,
    "question": "what will be the output when you compile and run the following piece of code?\n```cpp\nclass Test\n{\n    int x;\npublic:\n    Test()\n    {\n        x = 0;\n    }\n    Test(int y)\n    {\n        x = y++;\n    }\n    Test(Test &r)\n    {\n        x = r.x++;\n    }\n    void print()\n    {\n        cout<<x;\n    }\n};\nvoid main()\n{\n    Test t(1);\n    t.print();\n    Test x(t);\n    x.print();\n    t.print();\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "121"
      },
      {
        "id": "B",
        "text": "112"
      },
      {
        "id": "C",
        "text": "222"
      },
      {
        "id": "D",
        "text": "122"
      }
    ],
    "correct_answer": "B",
    "explanation": "â€«â€¬\nâ€«#### **1. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù† `t`**â€¬\nâ€«â€¬\nâ€«  * `Test t(1);`â€¬\nâ€«      * Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© ØªØ³ØªØ¯Ø¹ÙŠ **Ø§Ù„Ù…ÙÙ†Ø´Ø¦ (constructor)** `Test(int y)`.â€¬\nâ€«      * Ù‚ÙŠÙ…Ø© `y` Ù‡ÙŠ `1`.â€¬\nâ€«      * Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ÙÙ†Ø´Ø¦ØŒ ÙŠØªÙ… ØªÙ†ÙÙŠØ° `x = y++;`.â€¬\nâ€«          * Ø£ÙˆÙ„Ø§Ù‹ØŒ ÙŠØªÙ… Ø¥Ø³Ù†Ø§Ø¯ Ù‚ÙŠÙ…Ø© `y` Ø§Ù„Ø­Ø§Ù„ÙŠØ© (ÙˆÙ‡ÙŠ `1`) Ø¥Ù„Ù‰ Ø§Ù„Ù…ØªØºÙŠØ± `x`.â€¬\nâ€«          * Ø«Ø§Ù†ÙŠØ§Ù‹ØŒ ÙŠØªÙ… Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© `y` Ù„ØªØµØ¨Ø­ `2`.â€¬\nâ€«      * Ù†ØªÙŠØ¬Ø© Ù„Ø°Ù„ÙƒØŒ ÙŠØµØ¨Ø­ `t.x` ÙŠØ³Ø§ÙˆÙŠ `1`.â€¬\nâ€«â€¬\nâ€«-----â€¬\nâ€«â€¬\nâ€«#### **2. Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰**â€¬\nâ€«â€¬\nâ€«  * `t.print();`â€¬\nâ€«      * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØ·Ø¨Ø¹ Ù‚ÙŠÙ…Ø© `t.x`.â€¬\nâ€«      * Ø§Ù„Ù†Ø§ØªØ¬: `1`â€¬\nâ€«â€¬\nâ€«-----â€¬\nâ€«â€¬\nâ€«#### **3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù† `x` Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… `copy constructor`**â€¬\nâ€«â€¬\nâ€«  * `Test x(t);`â€¬\nâ€«      * Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© ØªØ³ØªØ¯Ø¹ÙŠ **Ù…ÙÙ†Ø´Ø¦ Ø§Ù„Ù†Ø³Ø® (copy constructor)** `Test(const Test& r)`.â€¬\nâ€«      * Ø§Ù„Ù…ØªØºÙŠØ± `r` Ù‡Ùˆ Ù…Ø±Ø¬Ø¹ (reference) Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù† `t`. Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù† Ø£ÙŠ ØªØºÙŠÙŠØ± Ø¹Ù„Ù‰ `r.x` Ø³ÙŠÙ†Ø¹ÙƒØ³ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¹Ù„Ù‰ `t.x`.â€¬\nâ€«      * Ø¯Ø§Ø®Ù„ Ù…ÙÙ†Ø´Ø¦ Ø§Ù„Ù†Ø³Ø®ØŒ ÙŠØªÙ… ØªÙ†ÙÙŠØ° `x = r.x++;`.â€¬\nâ€«          * Ø£ÙˆÙ„Ø§Ù‹ØŒ ÙŠØªÙ… Ø¥Ø³Ù†Ø§Ø¯ Ù‚ÙŠÙ…Ø© `r.x` Ø§Ù„Ø­Ø§Ù„ÙŠØ© (ÙˆÙ‡ÙŠ `t.x` Ø§Ù„ØªÙŠ ØªØ³Ø§ÙˆÙŠ `1`) Ø¥Ù„Ù‰ Ø§Ù„Ù…ØªØºÙŠØ± `x` Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯ `x`.â€¬\nâ€«          * Ø«Ø§Ù†ÙŠØ§Ù‹ØŒ ÙŠØªÙ… Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© `r.x` (Ø§Ù„ØªÙŠ Ù‡ÙŠ Ù†ÙØ³Ù‡Ø§ `t.x`) Ø¨ÙˆØ§Ø­Ø¯ØŒ ÙØªØµØ¨Ø­ `t.x` ØªØ³Ø§ÙˆÙŠ `2`.â€¬\nâ€«      * Ù†ØªÙŠØ¬Ø© Ù„Ø°Ù„ÙƒØŒ ÙŠØµØ¨Ø­ `x.x` ÙŠØ³Ø§ÙˆÙŠ `1`ØŒ Ø¨ÙŠÙ†Ù…Ø§ `t.x` ÙŠØµØ¨Ø­ `2`.â€¬\nâ€«â€¬\nâ€«-----â€¬\nâ€«â€¬\nâ€«#### **4. Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©**â€¬\nâ€«â€¬\nâ€«  * `x.print();`â€¬\nâ€«      * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØ·Ø¨Ø¹ Ù‚ÙŠÙ…Ø© `x.x`.â€¬\nâ€«      * Ø§Ù„Ù†Ø§ØªØ¬: `1`â€¬\nâ€«â€¬\nâ€«-----â€¬\nâ€«â€¬\nâ€«#### **5. Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©**â€¬\nâ€«â€¬\nâ€«  * `t.print();`â€¬\nâ€«      * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØ·Ø¨Ø¹ Ù‚ÙŠÙ…Ø© `t.x`.â€¬\nâ€«      * Ø§Ù„Ù†Ø§ØªØ¬: `2`â€¬\nâ€«â€¬\nâ€«-----â€¬\nâ€«â€¬\nâ€«### **Ø§Ù„Ù†Ø§ØªØ¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„ÙƒÙˆØ¯:**â€¬\nâ€«â€¬\nâ€«```â€¬\nâ€«1â€¬\nâ€«1â€¬\nâ€«2â€¬\nâ€«```â€¬\n```img\nhttps://i.postimg.cc/J0Z1zrHX/image.png\n```\n```cpp\n\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\n    int x;\npublic:\n    Test()\n    {\n        x = 0;\n    }\n    Test(int y) //1\n    {\n        x = y++;    //x=1 y=2\n    }\n    Test(Test &r)\n    {\n        x = r.x++;  // that mean x=1 y=2 the order of operations is 1. copy r.x to x 2. increment r.x //r.x mean reference to the original object\n    }  //1 to out then 2 after increasing for the new object\n/**\n * Function to print the value of member variable x\n * This is a member function of a class that outputs the value of x to the console\n */\n    void print()\n    {\n    // Output the value of member variable x to the standard output stream\n        cout<<x;\n    }\n};\nint main()\n{\n    Test t(1);\n    t.print();\n    Test x(t);  // call x.x = 1 , Copy Constructor , t.x became 2\n    x.print();\n    t.print(); // t again and x increased to 2 in last step // if x.print() will be 1 not 2\n    return 0;\n}\n\n```",
    "page": 0,
    "updated_at": "2025-08-20T20:33:13.876178"
  },
  {
    "id": 22,
    "question": "Given the class below, what changes do we need to make to the class in order to have a facility to add the values of an object's data to another?\n```cpp\nclass Test\n{\n    int x;\n    int y;\npublic:\n    Test()\n    {\n        x = 0;\n        y = 0;\n    }\n    void setXY(int a, int b)\n    {\n        x = a;\n        y = b;\n    }\n};\n```",
    "options": [
      {
        "id": "A",
        "text": "a. Do operator + overloading."
      },
      {
        "id": "B",
        "text": "b. Declare a third temporary member integer."
      },
      {
        "id": "C",
        "text": "c. Create a new member function: void Add(), that takes no parameters."
      },
      {
        "id": "D",
        "text": "d. All of the above."
      }
    ],
    "correct_answer": "A",
    "explanation": "To define the behavior of the `+` operator for `Test` objects (e.g., `test3 = test1 + test2`), you need to provide a custom implementation by overloading the `+` operator for the `Test` class.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 23,
    "question": "Object-Oriented is used because: (2 answers)",
    "options": [
      {
        "id": "A",
        "text": "A. The code is smaller."
      },
      {
        "id": "B",
        "text": "B. The program is faster."
      },
      {
        "id": "C",
        "text": "C. The code is reusable."
      },
      {
        "id": "D",
        "text": "D. The code is easy to maintain."
      }
    ],
    "correct_answer": [
      "C",
      "D"
    ],
    "explanation": "C. The code is reusable: One of the core benefits of Object-Oriented Programming (OOP) is reusability. Once a class is written, it can be reused in different parts of the program or even in different projects. This avoids redundancy, saves time, and reduces the risk of errors.\n\nD. The code is easy to maintain: OOP helps in creating modular code, where each class is a separate unit of functionality. This modularity makes it easier to maintain, update, or debug parts of the code without affecting the entire program. Changes to one class donâ€™t usually impact others, leading to easier management of the codebase over time.\n```img\nhttps://i.postimg.cc/jdYxk7B4/image.png\n```\n\nğŸ§º Reusability = Ø²ÙŠ Ù…Ø§ Ø¨Ù†Ø³ØªØ®Ø¯Ù… Ù†ÙØ³ Ø§Ù„Ø·Ø§Ø³Ø© ÙÙŠ ÙƒÙ„ Ø·Ø¨Ø®Ø©\nÙ…Ø´ Ù„Ø§Ø²Ù… Ù†Ø´ØªØ±ÙŠ Ø·Ø§Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø© ÙƒÙ„ Ù…Ø±Ø©ØŒ Ù†ÙØ³ Ø§Ù„Ø·Ø§Ø³Ø© ØªÙ†ÙØ¹ ÙÙŠ ÙƒØ°Ø§ Ø£ÙƒÙ„Ø©. Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§Ù† Ù…Ù…ÙƒÙ† Ù†Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙŠ ÙƒØ°Ø§ Ù…Ø´Ø±ÙˆØ¹.\n\nğŸ› ï¸ Maintainability = Ø²ÙŠ Ù„Ù…Ø§ ØªØ¨Ù†ÙŠ Ø¹Ù…Ø§Ø±Ø© Ù…Ù†Ø¸Ù…Ø©ØŒ ØªÙ‚Ø¯Ø± ØªØµÙ„Ø­ Ø£ÙŠ Ø­Ø§Ø¬Ø© Ø¨Ø³Ù‡ÙˆÙ„Ø©\nÙ„Ùˆ ÙƒÙ„ Ø´Ù‚Ø© Ù„ÙŠÙ‡Ø§ Ù†Ø¸Ø§Ù…ØŒ ØªÙ‚Ø¯Ø± ØªØ¯Ø®Ù„ ØªØµÙ„Ø­ Ø§Ù„ØªÙƒÙŠÙŠÙ Ø£Ùˆ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¡ Ø¨Ø³Ù‡ÙˆÙ„Ø©. Ù†ÙØ³ Ø§Ù„ÙƒÙ„Ø§Ù… ÙÙŠ OOPØŒ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ù†Ø¸Ù… Ø³Ù‡Ù„ Ø§Ù„ØµÙŠØ§Ù†Ø©.",
    "page": 0,
    "updated_at": "2025-08-16T22:19:10.377060"
  },
  {
    "id": 24,
    "question": "We use the inheritance for:",
    "options": [
      {
        "id": "A",
        "text": "Increasing more member functions only to the base class."
      },
      {
        "id": "B",
        "text": "Extending base class functionality."
      },
      {
        "id": "C",
        "text": "Including the base class."
      }
    ],
    "correct_answer": "B",
    "explanation": "Inheritance is a fundamental OOP mechanism that allows a new class (derived) to inherit properties and behaviors from an existing class (base), and then extend or modify that functionality for more specialized use.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 25,
    "question": "The following are examples of polymorphism: (2 answers)",
    "options": [
      {
        "id": "A",
        "text": "a. Operator overloading"
      },
      {
        "id": "B",
        "text": "b. Function overriding"
      },
      {
        "id": "C",
        "text": "c. Friend functions"
      },
      {
        "id": "D",
        "text": "d. Constructor overloading"
      }
    ],
    "correct_answer": [
      "A",
      "B"
    ],
    "explanation": "Correct Choices: A, B\n\nOperator overloading (A) supports compile-time polymorphism by allowing operators to behave differently based on types.\nFunction overriding (B) supports run-time polymorphism by allowing derived classes to redefine a base classâ€™s function.\n\nâ€«Ø§Ù„Ù€ Polymorphism (ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø´ÙƒØ§Ù„) Ù…Ø¹Ù†Ø§Ù‡Ø§ Ø¥Ù† Ø§Ù„Ø­Ø§Ø¬Ø© Ù…Ù…ÙƒÙ† ØªØ§Ø®Ø¯ Ø£ÙƒØªØ± Ù…Ù† Ø´ÙƒÙ„ Ø£Ùˆ ØªØ¹Ù…Ù„ Ø£ÙƒØªØ± Ù…Ù† ÙˆØ¸ÙŠÙØ©.â€¬\nâ€«â€¬\nâ€«Ø£Ù…Ø«Ù„ØªÙ‡Ø§ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:â€¬\nâ€«â€¬\nâ€«Operator Overloading (ØªØ¹Ø¯Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª):â€¬\nâ€«Ø¨ØªØ³Ù…Ø­ Ù„Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª (Ù…Ø«Ù„ + Ø£Ùˆ ==) Ø¥Ù†Ù‡Ø§ ØªØªØµØ±Ù Ø¨Ø´ÙƒÙ„ Ù…Ø®ØªÙ„Ù Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„ÙŠ Ø¨ØªØ´ØªØºÙ„ Ø¹Ù„ÙŠÙ‡Ø§. Ø¯Ù‡ Ø¨ÙŠØ¹ØªØ¨Ø± compile-time polymorphism.â€¬\nâ€«â€¬\nâ€«Function Overriding (Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¯ÙˆØ§Ù„):â€¬\nâ€«Ø¨ØªØ­ØµÙ„ Ù„Ù…Ø§ Ø§Ù„Ù€ derived class ØªÙˆÙØ± ØªØ·Ø¨ÙŠÙ‚ Ø®Ø§Øµ Ø¨ÙŠÙ‡Ø§ Ù„Ø¯Ø§Ù„Ø© Ù…Ø¹ÙŠÙ†Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ù€ base class. Ø¯Ù‡ Ø¨ÙŠÙƒÙˆÙ† run-time polymorphism.â€¬\nâ€«â€¬\nâ€«â€¢ Ù„ÙŠÙ‡ Ù…Ø´ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±Ø§ØªØŸâ€¬\nâ€«â€¬\nâ€«Friend functions:â€¬\nâ€«Ø¯ÙˆØ§Ù„ Ù„ÙŠÙ‡Ø§ ØµÙ„Ø§Ø­ÙŠØ§Øª ÙˆØµÙˆÙ„ Ø®Ø§ØµØ© Ù„Ù€ protected Ùˆprivate members Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙ„Ø§Ø³ØŒ Ù„ÙƒÙ†Ù‡Ø§ Ù…Ø´ Ø´ÙƒÙ„ Ù…Ù† Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù€ polymorphism.â€¬\nâ€«â€¬\nâ€«Constructor Overloading:â€¬\nâ€«Ø¯Ù‡ Ù†ÙˆØ¹ Ù…Ù† Ø§Ù„Ù€ function overloadingØŒ Ù„ÙƒÙ†Ù‡ Ù…Ø´ Ù…Ø±ØªØ¨Ø· Ø¨Ù€ polymorphism.â€¬",
    "page": 0,
    "updated_at": "2025-08-20T20:52:41.805203"
  },
  {
    "id": 26,
    "question": "```cpp\nclass XX\n{\n    int i;\n    char c;\n    void seti (int r) { }\n    char getc () { return c; }\n};\nvoid main()\n{\n    XX x;\n    x.seti(8);\n}\n```\nOn running, the previous code:",
    "options": [
      {
        "id": "A",
        "text": "compiles with no errors"
      },
      {
        "id": "B",
        "text": "the compiler generates an error because the class XX cannot be instantiated because it has no public constructor."
      },
      {
        "id": "C",
        "text": "The linker generates an error because the class XX cannot be instantiated because it has no public constructor."
      },
      {
        "id": "D",
        "text": "The compiler generates an error because the method â€œsetiâ€ is non accessible through object x."
      }
    ],
    "correct_answer": "D",
    "explanation": "In a C++ class, members are private by default if no access specifier is used. Thus, `seti` is a private method. The `main` function is outside the class and cannot access private members, leading to a compilation error.\n```cpp\n|15|error: 'void XX::seti(int)' is private within this context|\n```",
    "page": 0,
    "updated_at": "2025-08-20T20:46:33.958585"
  },
  {
    "id": 27,
    "question": "In C++, on calling the previous function:\n```cpp\nvoid printNumber()\n{\n    int num=5;\n    for (i=0; i<10; i++)\n    { cout<<num; }\n    int i;\n    char c;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "An error occurs because i & c cannot be declared after the loop (invalid declaration)."
      },
      {
        "id": "B",
        "text": "An error occurs because the var i is not visible in the for loop (undefined symbol i)"
      },
      {
        "id": "C",
        "text": "No error occurs."
      }
    ],
    "correct_answer": "B",
    "explanation": "The variable `i` is used in the `for` loop `(i=0; ...)` before it is declared. In C++, a variable must be declared before its first use. The declaration `int i;` comes after the loop, causing an 'undefined symbol' or 'not declared in this scope' compiler error.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 28,
    "question": "The constructor of the base class called automatically:",
    "options": [
      {
        "id": "A",
        "text": "When any member function of the derived class called."
      },
      {
        "id": "B",
        "text": "After the constructor of the derived class started."
      },
      {
        "id": "C",
        "text": "Before the constructor of the derived class started."
      },
      {
        "id": "D",
        "text": "We do not know when exactly it will be started."
      }
    ],
    "correct_answer": "C",
    "explanation": "In C++, when you create an object of a derived class, the base class constructor is called first, automatically, before the derived class constructor begins execution.\n\nThis ensures that the base part of the object is properly initialized before the derived part adds its own behavior.\n\nğŸ”§ Example:\n```cpp\nclass Base {\npublic:\n    Base() { std::cout << \"Base constructor\\n\"; }\n};\n\nclass Derived : public Base {\npublic:\n    Derived() { std::cout << \"Derived constructor\\n\"; }\n};\n\nint main() {\n    Derived d;\n}\n```\n\n\nOutput:\n\n```cpp\nBase constructor\nDerived constructor\n```\n\nğŸ—ï¸ Ø²ÙŠ Ù…Ø§ Ø¨Ù†Ø¨Ù†ÙŠ Ø§Ù„Ø£Ø³Ø§Ø³ Ù‚Ø¨Ù„ Ù…Ø§ Ù†ÙƒÙ…Ù„ Ø§Ù„Ø¹Ù…Ø§Ø±Ø©\nÙ…ÙŠÙ†ÙØ¹Ø´ Ù†Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù†ÙŠ Ù‚Ø¨Ù„ Ù…Ø§ Ù†Ø¨Ù†ÙŠ Ø§Ù„Ø£Ø³Ø§Ø³. Ù†ÙØ³ Ø§Ù„ÙƒÙ„Ø§Ù… ÙÙŠ Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©ØŒ Ù„Ø§Ø²Ù… Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ÙŠØªØ¨Ù†ÙŠ Ø§Ù„Ø£ÙˆÙ„ Ù‚Ø¨Ù„ Ù…Ø§ Ù†ÙƒÙ…Ù„ Ø¨Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ØªÙ‚.",
    "page": 0,
    "updated_at": "2025-08-16T22:23:35.765452"
  },
  {
    "id": 29,
    "question": "Which can best be written in the space?\n```cpp\nclass X\n{\n    int k;\npublic:\n    void setK(int k) {........}\n};\n```",
    "options": [
      {
        "id": "A",
        "text": "this->k=k;"
      },
      {
        "id": "B",
        "text": "k=k;"
      },
      {
        "id": "C",
        "text": "this.k=k;"
      }
    ],
    "correct_answer": "A",
    "explanation": "In the method void setK(int k), the parameter k shadows the member variable k. To distinguish between them, you use the this pointer:\n\n```cpp\nvoid setK(int k) {\n    this->k = k; // Assign parameter k to member variable k\n}\n```\nthis->k refers to the member variable\nk refers to the parameter.\n\nâŒ Why the others are incorrect:\nk = k;\t  :    Assigns the parameter to itself â€” member variable remains unchanged.\nthis.k = k;  :\tInvalid syntax in C++ â€” this is a pointer, so you must use -> not .\n\nâ€«ÙÙŠ Ø§Ù„Ù€ method void setK(int k)ØŒ Ø§Ø³Ù… Ø§Ù„Ù€ parameter k Ø¨ÙŠØ¹Ù…Ù„ Ø­Ø§Ø¬Ø© Ø§Ø³Ù…Ù‡Ø§ \"shadowing\"ØŒ ÙŠØ¹Ù†ÙŠ Ø¨ÙŠØ®ÙÙŠ Ø§Ù„Ù€ member variable Ø§Ù„Ù„ÙŠ Ø¨Ù†ÙØ³ Ø§Ù„Ø§Ø³Ù… Ø¬ÙˆÙ‡ Ø§Ù„Ù€ method. Ø¹Ø´Ø§Ù† ØªÙØ±Ù‚ Ù…Ø§ Ø¨ÙŠÙ†Ù‡Ù… ÙˆØªÙˆØ¶Ø­ Ø¥Ù†Ùƒ Ø¹Ø§ÙŠØ² ØªØ´ÙŠØ± Ù„Ù„Ù€ member variableØŒ Ø¨ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ù€ this pointer.â€¬\nâ€«Ø§Ù„Ù€ this pointer Ø¨ÙŠØ´Ø§ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù€ object Ø§Ù„Ø­Ø§Ù„ÙŠ.â€¬\nâ€«â€¬\nâ€«member variable Ø¨ØªØ´ÙŠØ± Ù„Ù€ this->kâ€¬\nâ€«â€¬\nâ€«parameter Ø¨ØªØ´ÙŠØ± Ù„Ù€ kâ€¬\nâ€«â€¬\nâ€«â€¢ Ù„ÙŠÙ‡ Ù…Ø´ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±Ø§ØªØŸâ€¬\nâ€«â€¬\nâ€«k = k: Ø¯Ù‡ Ù‡ØªØ®Ù„ÙŠ Ø§Ù„Ù€ parameter ÙŠØ§Ø®Ø¯ Ù‚ÙŠÙ…Ø© Ù†ÙØ³Ù‡ØŒ ÙˆØ§Ù„Ù€ member variable Ù…Ø´ Ù‡ØªØªØºÙŠØ±.â€¬\nâ€«â€¬\nâ€«syntax ØºÙ„Ø·: Ø¯Ù‡ Ù…Ø´ ØµØ­ ÙÙŠ C++ØŒ Ù„Ø£Ù†Ùƒ Ù„Ø§Ø²Ù… ØªØ³ØªØ®Ø¯Ù… dot operator (.) Ù…Ø´ arrow operator (<-) Ù…Ø¹ Ø§Ù„Ù€ this pointerØŒ ÙŠØ¹Ù†ÙŠ Ù„Ø§Ø²Ù… ØªÙƒØªØ¨ this->k = k Ø¨Ø¯Ù„Ù‹Ø§ Ù…Ù† this.k = k.â€¬",
    "page": 0,
    "updated_at": "2025-08-20T21:11:02.505097"
  },
  {
    "id": 30,
    "question": "The previous code:\n```cpp\nclass Person\n{\npublic:\n    virtual void talk() = 0;\n};\nclass Adult: public Person\n{\npublic:\n     void talk() { cout << \"Hello\"; }\n};\nclass Female: public Person\n{\npublic:\n       void talk() { cout << \"Hi\"; }\n};\nvoid main()\n{\n    Person p;\n    Adult a;\n    Female f;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Compiles successfully."
      },
      {
        "id": "B",
        "text": "Produces an error."
      }
    ],
    "correct_answer": "B",
    "explanation": "The line Person p; causes a compilation error because:\n\nPerson is an abstract class. it contains a pure virtual function\n```cpp\nvirtual void talk() = 0;\n```\nYou cannot instantiate an abstract class directly.\n\n\nâœ… How to fix it:\nYou can create pointers or references to Person, but not direct objects:\n```cpp\nPerson* p1 = new Adult();   // âœ… OK\nPerson* p2 = new Female();  // âœ… OK\n```\nğŸš« Ø²ÙŠ Ù…Ø§ Ù…ÙŠÙ†ÙØ¹Ø´ ØªØ±ÙƒØ¨ Ø¹Ø±Ø¨ÙŠØ© Ù…Ù† ØºÙŠØ± Ù…ÙˆØªÙˆØ±\nØ§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡ Ø¯Ø§Ù„Ø© virtual = 0 Ø²ÙŠ Ø¹Ø±Ø¨ÙŠØ© Ù…Ù† ØºÙŠØ± Ù…ÙˆØªÙˆØ±. Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠÙ‡ Ù†Ø³Ø®Ø© ÙƒØ§Ù…Ù„Ø© (Ù…Ø´ØªÙ‚Ø©) Ø¹Ù„Ø´Ø§Ù† ØªØ´ØªØºÙ„. Ù…ÙŠÙ†ÙØ¹Ø´ ØªØ³ØªØ®Ø¯Ù…Ù‡Ø§ Ù„ÙˆØ­Ø¯Ù‡Ø§.",
    "page": 0,
    "updated_at": "2025-08-16T22:30:14.555320"
  },
  {
    "id": 31,
    "question": "What are the expected constructors that must exist in the base class?\n```cpp\nclass Child: public Base\n{\npublic:\n    Child(int x) { }\n    Child(int x,int y) : Base(x,y)\n    {}\n};\n```",
    "options": [
      {
        "id": "A",
        "text": "Base(), Base(int,int)"
      },
      {
        "id": "B",
        "text": "Base(), Base(int)"
      },
      {
        "id": "C",
        "text": "Base(int), Base(int,int)"
      },
      {
        "id": "D",
        "text": "Base(int,int)"
      }
    ],
    "correct_answer": "A",
    "explanation": "The constructor `Child(int x)` has no initializer list, so the compiler will implicitly try to call the default constructor of the base class, `Base()`. The constructor `Child(int x, int y)` explicitly calls `Base(x,y)` in its initializer list, which requires a constructor `Base(int, int)`. Therefore, both must exist.\n\n\nâ€«Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±Ø­ Ø§Ù„Ù…Ù‚Ø¯Ù…ØŒ Ø§Ù„Ø¬ÙˆØ§Ø¨ Ø§Ù„ØµØ­ÙŠØ­ Ù‡Ùˆ Ø£Ù† Ø§Ù„Ù€ Base class ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„Ø§ Ù…Ù† default constructor (Base()) Ùˆconstructor Ù…ÙØ¹Ø§Ù…Ù„ÙŠ (Base(int, int)) Ù„ØªØ¬Ù†Ø¨ Ø£ÙŠ compilation error.â€¬\nâ€«Ø§Ù„Ø´Ø±Ø­:â€¬\nâ€«â€¬\nâ€«Default Constructor (Base()):â€¬\nâ€«â€¬\nâ€«Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ØªÙ‚ (Child)ØŒ Ø§Ù„Ù€ compiler ÙŠØ­Ø§ÙˆÙ„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ default constructor Ù„Ù„Ù€ Base class ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠ constructor Ø¨Ø´ÙƒÙ„ ØµØ±ÙŠØ­.â€¬\nâ€«Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ default constructor Ù…ÙØ¹Ø±Ù ÙÙŠ Ø§Ù„Ù€ Base classØŒ Ø³ÙŠØ­Ø¯Ø« compilation error.â€¬\nâ€«â€¬\nâ€«â€¬\nâ€«Parameterized Constructor (Base(int, int)):â€¬\nâ€«â€¬\nâ€«ÙÙŠ Ø­Ø§Ù„Ø© ÙˆØ¬ÙˆØ¯ constructor ÙÙŠ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ØªÙ‚ Ù…Ø«Ù„ Child(int x, int y) ÙŠØ³ØªØ¯Ø¹ÙŠ ØµØ±Ø§Ø­Ø©Ù‹ Ø§Ù„Ù€ constructor Ù„Ù„Ù€ Base class Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… initializer list (Ù…Ø«Ù„ Base(x, y))ØŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ constructor ÙÙŠ Ø§Ù„Ù€ Base class ÙŠÙ‚Ø¨Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù€ parameters (Base(int, int)).â€¬\nâ€«Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ØŒ Ø³ÙŠØ­Ø¯Ø« compilation error.â€¬\nâ€«â€¬\nâ€«â€¬\nâ€«â€¬\nâ€«Ø§Ù„Ø®Ù„Ø§ØµØ©:â€¬\nâ€«Ù„ÙƒÙŠ ÙŠØ¹Ù…Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø¯ÙˆÙ† Ø£Ø®Ø·Ø§Ø¡ØŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø§Ù„Ù€ Base class Ø¹Ù„Ù‰:â€¬\nâ€«â€¬\nâ€«Default constructor (Base()) Ù„ØªØºØ·ÙŠØ© Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„ØªÙŠ ÙŠØªÙ… ÙÙŠÙ‡Ø§ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ Base class Ø¨Ø¯ÙˆÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª.â€¬\nâ€«Parameterized constructor (Base(int, int)) Ù„ØªØºØ·ÙŠØ© Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„ØªÙŠ ÙŠØªÙ… ÙÙŠÙ‡Ø§ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ Base class Ø¨Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ù€ initializer list ÙÙŠ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ØªÙ‚.â€¬â€¬",
    "page": 0,
    "updated_at": "2025-08-20T21:18:42.135225"
  },
  {
    "id": 32,
    "question": "The class that contains a pure virtual function is called:",
    "options": [
      {
        "id": "A",
        "text": "Base class."
      },
      {
        "id": "B",
        "text": "Derived class."
      },
      {
        "id": "C",
        "text": "Abstract class."
      },
      {
        "id": "D",
        "text": "Embedded class."
      }
    ],
    "correct_answer": "C",
    "explanation": "By definition, a class in C++ that contains one or more pure virtual functions is known as an abstract class. It serves as a blueprint for derived classes and cannot be instantiated on its own.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 33,
    "question": "The previous code prints:\n```cpp\nclass XX\n{\n    int i;\n    char c;\npublic:\n    void seti(int r) {}\n    void getc() { return c; }\n    void printHi() { cout << \"Hi\"; }\n};\nvoid printHi() { cout << \"Hello\"; }\nvoid main()\n{\n    XX x;\n    x.printHi();\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Hello."
      },
      {
        "id": "B",
        "text": "Hi."
      },
      {
        "id": "C",
        "text": "Hi then Hello"
      },
      {
        "id": "D",
        "text": "None of the above, it generates an error."
      }
    ],
    "correct_answer": "D",
    "explanation": "void has no return value\n```img\nhttps://i.postimg.cc/bJ7QHhkc/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-20T21:25:21.691549"
  },
  {
    "id": 34,
    "question": "In the previous code:\n```cpp\nclass Student\n{\n    char name[20];\npublic:\n    Student() { strcpy(name, \"Anonymous\"); cout<<name;}\n    Student(char* nm) { strcpy(name,nm); cout<<name;}\n    ~Student() {}\n};\nvoid main()\n{\n    Student s1(\"Mona\");      // ......1\n    Student *s2;             // ......2\n    s2 = new Student(\"Ali\"); // ......3\n    delete s1;               // ......4\n    delete s2;               // ......5\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "It compiles successfully."
      },
      {
        "id": "B",
        "text": "Line 4 generates an error."
      },
      {
        "id": "C",
        "text": "Line 5 generates an error."
      },
      {
        "id": "D",
        "text": "Both lines 4,5 generate errors."
      }
    ],
    "correct_answer": "B",
    "explanation": "The object `s1` is created on the stack (automatic storage duration). The `delete` operator can only be used on pointers to memory allocated with `new` (dynamic storage duration). Attempting to `delete` a stack object like `s1` is a compilation error.\n\nAfter fixing by commenting stack delete\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Student\n{\n    char name[20];\npublic:\n    Student() { strcpy(name, \"Anonymous\"); cout<<name;}\n    Student(char* nm) { strcpy(name,nm); cout<<name;}\n    ~Student() {}\n};\nint main()\n{\n  Student s1(\"Mona\");      // ......1\n    Student *s2;             // ......2\n    s2 = new Student(\"Ali\"); // ......3\n    //delete s1;               // ......4\n    delete s2;               // ......5\n}\n```\n\nOutput is : MonaAli",
    "page": 0,
    "updated_at": "2025-08-20T21:31:03.747971"
  },
  {
    "id": 35,
    "question": "Which of the statements below is true?\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\npublic:\n    void print(int i)         // ..1\n    { cout << \"int version\"; }  // ..2\n    void print(char *c)       // ..3\n    { cout << \"char version\"; } // ..4\n};\n\nvoid main()\n{\n    Test t;                   // ..5\n    char ch = 'p';            // ..6\n    t.print(ch);              // ..7\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Line 4 will not compile, because void methods cannot be overloaded."
      },
      {
        "id": "B",
        "text": "Line 7 will not compile, because there is no version of print that takes a char."
      },
      {
        "id": "C",
        "text": "The code will compile and produce the following output: int version."
      },
      {
        "id": "D",
        "text": "The code will compile and produce the following output: char version."
      }
    ],
    "correct_answer": "C",
    "explanation": "The code compiles and outputs int version because t.print(ch) with char ch = p resolves to void print(int i) via implicit char-to-int conversion, not void print(char *c).\n\n```img\nhttps://i.postimg.cc/g0TgL108/image.png\n```\n\nto try print char version remove pointer argument:\n\n```cpp\n\n\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\npublic:\n    void print(int i)         // ..1\n    { cout << \"int version\"; }  // ..2\n    void print(char c)       // ..3\n    { cout << \"char version\"; } // ..4\n};\nint main()\n{\nTest t;                   // ..5\n    char ch = 'p';            // ..6\n    t.print(ch);              // ..7\n}\n```",
    "page": 0,
    "updated_at": "2025-08-20T21:42:33.692162"
  },
  {
    "id": 36,
    "question": "What happens in program?\n```cpp\nclass Base\n{\npublic:\n    int x;\n};\nclass Child: private Base\n{\npublic:\n    int y;\n};\nvoid main()\n{\n    Child c;\n    c.x=10;\n    cout<<\"x=\"<<x;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Compiler error because x is not declared in Child class."
      },
      {
        "id": "B",
        "text": "Compiler error because of the Child inheritance from private class."
      },
      {
        "id": "C",
        "text": "x=10"
      },
      {
        "id": "D",
        "text": "Runtime error."
      }
    ],
    "correct_answer": "B",
    "explanation": "When `Child` inherits from `Base` using `private` inheritance, all `public` members of `Base` (like `x`) become `private` members of `Child`. Therefore, `x` cannot be accessed from outside the `Child` class, such as in the `main` function. The line `c.x=10;` will cause a compilation error.\n```img\nhttps://i.postimg.cc/c1MfVVNh/image.png\n```\n\nØ§Ù„ØªØµØ­ÙŠØ­:\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n    int x;\n};\nclass Child: public Base // ØªØºÙŠÙŠØ± Ø¥Ù„Ù‰ public inheritance\n{\npublic:\n    int y;\n};\nint main() // ØªØµØ­ÙŠØ­ Ø¥Ù„Ù‰ int main\n{\n    Child c;\n    c.x = 10; // Ø§Ù„Ø¢Ù† ÙŠØ¹Ù…Ù„ Ù„Ø£Ù† x public\n    cout << \"x=\" << c.x; // ØªØµØ­ÙŠØ­ Ø¥Ù„Ù‰ c.x\n    return 0;\n}\n```",
    "page": 0,
    "updated_at": "2025-08-20T21:46:07.516810"
  },
  {
    "id": 37,
    "question": "A constructor is:",
    "options": [
      {
        "id": "A",
        "text": "a) A member function that removes an object from the memory."
      },
      {
        "id": "B",
        "text": "b) A member function that is called automatically when an object is being removed from the memory."
      },
      {
        "id": "C",
        "text": "c) A member function that is used to initialize variables of a declared object."
      },
      {
        "id": "D",
        "text": "d) None of the above."
      }
    ],
    "correct_answer": "C",
    "explanation": "A constructor is a special member function whose primary purpose is to initialize the data members of an object when it is created. Options (a) and (b) describe a destructor.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 38,
    "question": "Given the class below, what changes do we need to make to the class in order to have a facility to test if the values of two objects' data are equal?\n```cpp\nclass MyClass\n{\nprivate:\n    float a;\n    float b;\npublic:\n    MyClass()\n    {\n        a = 0 ;\n        b = 0;\n    }\n    void setValues (int x, int y)\n    {\n        a = x;\n        b = y;\n    }\n};\n```",
    "options": [
      {
        "id": "A",
        "text": "a) Declare a third temporary member integer."
      },
      {
        "id": "B",
        "text": "b) Do operator == overloading."
      },
      {
        "id": "C",
        "text": "c) Create a new member function: void testEqual( ), that takes no parameters."
      },
      {
        "id": "D",
        "text": "d) None of the above"
      }
    ],
    "correct_answer": "B",
    "explanation": "To provide a custom comparison for equality between two objects of `MyClass`, you should overload the `==` operator. This allows for intuitive syntax like `if (obj1 == obj2)`.\n```img\nhttps://i.postimg.cc/RFvwFR7K/image.png\n```\n```cpp\nclass MyClass\n{\nprivate:\n    float a;\n    float b;\npublic:\n    MyClass()\n    {\n        a = 0;\n        b = 0;\n    }\n    void setValues(int x, int y)\n    {\n        a = x;\n        b = y;\n    }\n    // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„ ==\n    bool operator==(const MyClass& other) const\n    {\n        return (a == other.a && b == other.b);\n    }\n};\n```\n```img\nhttps://i.postimg.cc/wjJNQPFD/image.png\n```\nØ§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø«Ø§Ù„:\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    MyClass obj1, obj2;\n    obj1.setValues(5, 10);\n    obj2.setValues(5, 10);\n    if (obj1 == obj2)\n        cout << \"Objects are equal\" << endl;\n    else\n        cout << \"Objects are not equal\" << endl;\n    return 0;\n}\n```\n```img\nhttps://i.postimg.cc/sXfZy2zJ/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-20T21:54:37.565513"
  },
  {
    "id": 39,
    "question": "Which of the following statements are true about destructors?",
    "options": [
      {
        "id": "A",
        "text": "a) Destructors are special functions with the same name of the class and are preceded by a tilde character (~)."
      },
      {
        "id": "B",
        "text": "b) Destructors cannot be overloaded."
      },
      {
        "id": "C",
        "text": "c) A destructor has no return type."
      },
      {
        "id": "D",
        "text": "d) All of the above."
      },
      {
        "id": "E",
        "text": "e) None of the above."
      }
    ],
    "correct_answer": "D",
    "explanation": "All three statements are correct definitions of a destructor's properties in C++. They are named `~ClassName`, a class can only have one (cannot be overloaded), and they have no return type, not even `void`.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 40,
    "question": "Which of the following most closely describes the process of overloading?",
    "options": [
      {
        "id": "A",
        "text": "a) A class with the same name replaces the functionality of a class defined earlier in the hierarchy."
      },
      {
        "id": "B",
        "text": "b) A method with the same name completely replaces the functionality of a method defined earlier in the hierarchy."
      },
      {
        "id": "C",
        "text": "c) A method with the same name but different parameters gives multiple uses for the same method name."
      },
      {
        "id": "D",
        "text": "d) A class is prevented from accessing methods in its immediate ancestor."
      }
    ],
    "correct_answer": "C",
    "explanation": "Function overloading allows multiple functions in the same scope to have the same name, as long as they have different parameter lists (different number, type, or order of parameters). This is a form of compile-time polymorphism.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 41,
    "question": "What will happen when you attempt to compile the code below?\n```cpp\nclass MyClass\n{\n    int x;\npublic:\n    int y;\n};\nvoid main()\n{\n    MyClass obj;\n    obj.x = 100;\n    obj.y = 500;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "a) Compiler Error because x is not accessible."
      },
      {
        "id": "B",
        "text": "b) Compiler Error because y is not accessible."
      },
      {
        "id": "C",
        "text": "c) Compiler Error because MyClass is an abstract class and can not be instantiated."
      },
      {
        "id": "D",
        "text": "d) a and b."
      },
      {
        "id": "E",
        "text": "e) The code will compile successfully."
      }
    ],
    "correct_answer": "A",
    "explanation": "In a C++ class, members are `private` by default. Since `int x` is declared before any access specifier, it is private. The `main` function, being outside the class, cannot access private members. The line `obj.x = 100;` will cause a compilation error.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 42,
    "question": "The following function prototype uses the default arguments feature: ```cpp void myFunc(int x=3, int y);``` is the function valid this way?",
    "options": [
      {
        "id": "A",
        "text": "a) Yes, it is ok to give a default parameter for x and not for y."
      },
      {
        "id": "B",
        "text": "b) No, a function must always declare all its variables with default values."
      },
      {
        "id": "C",
        "text": "c) No, you must only give a default parameter for y but not for x."
      },
      {
        "id": "D",
        "text": "d) No, there should not be any arguments without default values to the right of the default arguments."
      }
    ],
    "correct_answer": "D",
    "explanation": "In C++, parameters with default values must be the trailing (rightmost) parameters in the function's signature. Once you provide a default argument for a parameter, all subsequent parameters must also have default arguments. Here, `y` does not have a default value but follows `x` which does, making the prototype invalid.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 43,
    "question": "A derived(sub)(child)(inherited) class can directly access:",
    "options": [
      {
        "id": "A",
        "text": "a) The protected and public members of the base class."
      },
      {
        "id": "B",
        "text": "b) The private and protected members of the base class."
      },
      {
        "id": "C",
        "text": "c) Only the protected members of the base class."
      },
      {
        "id": "D",
        "text": "d) Only the private members of the base class."
      },
      {
        "id": "E",
        "text": "e) The public, private, and protected members of the base class."
      }
    ],
    "correct_answer": "A",
    "explanation": "A derived class inherits from a base class and can directly access its `public` and `protected` members. It cannot directly access the `private` members of the base class.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 44,
    "question": "Assume you have a class X that contains an object of class Y. Assume that we declare an object of class X in the main() function. When will the body of the constructor of class Y be executed?",
    "options": [
      {
        "id": "A",
        "text": "a) When any member function of the class X is called."
      },
      {
        "id": "B",
        "text": "b) After the body of the constructor of class X is executed."
      },
      {
        "id": "C",
        "text": "c) Before the body of the constructor of class X is executed."
      },
      {
        "id": "D",
        "text": "d) We can not determine exactly when it will be executed."
      }
    ],
    "correct_answer": "C",
    "explanation": "This describes composition (a 'has-a' relationship). When an object of the container class `X` is constructed, all its member objects (like the `Y` object) must be fully constructed first. Therefore, the constructor for `Y` runs before the code inside the body of `X`'s constructor.\n ```img\nhttps://i.postimg.cc/zGLstwRC/image.png\n ```\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Y {\npublic:\n    Y() {\n        cout << \"Y constructor called\" << endl;\n    }\n};\n\nclass X {\n    Y y; // ÙƒØ§Ø¦Ù† Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ Y ÙƒØ¹Ø¶Ùˆ\npublic:\n    X() {\n        cout << \"X constructor called\" << endl;\n    }\n};\n\nint main() {\n    X x; // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ X\n    return 0;\n}\n ```\noutput:\n```cpp\nY constructor called\nX constructor called\n```\n```img\nhttps://i.postimg.cc/pdRBhRxm/image.png\n ```",
    "page": 0,
    "updated_at": "2025-08-20T22:04:13.093587"
  },
  {
    "id": 45,
    "question": "An embedded (aggregated) object is:",
    "options": [
      {
        "id": "A",
        "text": "a) An object that s declared with the default constructor."
      },
      {
        "id": "B",
        "text": "b) An object that is included by another object."
      },
      {
        "id": "C",
        "text": "c) An object from a class that is inherited from another class."
      },
      {
        "id": "D",
        "text": "d) b and c."
      },
      {
        "id": "E",
        "text": "e) None of the above."
      }
    ],
    "correct_answer": "B",
    "explanation": "An embedded, or member, object is an instance of one class that is a data member of another class. This represents a 'has-a' relationship, which is a key part of both composition and aggregation.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 46,
    "question": "To write copy constructor to class point, what would be its signature?\n```cpp\n. class Point\n{\n    float x, y;\n    Point (float a, float b) { x=a; y=b;}\n    Point () { x=0; y=0; }\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Point (Point)"
      },
      {
        "id": "B",
        "text": "Point (Point &)"
      },
      {
        "id": "C",
        "text": "Point & Point (Point &)."
      },
      {
        "id": "D",
        "text": "Point & Point (Point)"
      }
    ],
    "correct_answer": "B",
    "explanation": "A copy constructor is a special constructor used to create a new object as a copy of an existing object.\n\nThe parameter type must be a reference to an existing object, and the object should not be modified, hence it is passed as a const reference.\n\nSo the correct option is:\nPoint(const Point &)\n\nHere's the updated class with a proper copy constructor:\n\n ```cpp\n class Point\n{\n    float x, y;\npublic:\n    Point(float a, float b) { x = a; y = b; }\n    Point() { x = 0; y = 0; }\n    \n    // Copy constructor\n    Point(const Point &p) { x = p.x; y = p.y; }\n};\n ```\n\n\nPoint(Point &) is incorrect because passing by reference without const would allow modification of the original object, which is not the purpose of a copy constructor.\n\nPoint & Point(Point &) is incorrect because copy constructors should return nothing (void return type) and not a reference.\n\nvoid Point(Point) and void Point(Point &) are also incorrect for the same reason â€” copy constructors don't have a return type.\n\n",
    "page": 0,
    "updated_at": "2025-08-10T16:51:52.262969"
  },
  {
    "id": 47,
    "question": "What is the output of the following code?\n```cpp\n. class Nice\n{ \n    int a;\npublic:\n    Nice() { a = 0; }\n    Nice(Nice & myN)\n    { \n        this-> a = myN.a;\n        cout<<\"I am the copy constructor \";\n    }\n    void setA(int m) { a = m; }\n    int getA() { return a; }\n};\nvoid show(Nice &obj)\n{\n    cout<<\"I am the show function, value is: \" << obj.getA();\n}\nvoid main()\n{ \n    Nice n1;\n    n1.setA(15);\n    show(n1);\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "I am the show function, value is: 15."
      },
      {
        "id": "B",
        "text": "I am the copy constructor I am the show function, value is: 15."
      },
      {
        "id": "C",
        "text": "I am the show function, value is: 0."
      },
      {
        "id": "D",
        "text": "Compilation Error."
      }
    ],
    "correct_answer": "A",
    "explanation": "The `show` function takes its parameter `obj` by reference (`Nice &obj`). When an object is passed by reference, no copy is made, and the copy constructor is not called. Therefore, only the output from the `show` function itself will be printed.\n\nLet's trace the execution of your code step by step to determine the correct output:\nStep-by-Step Trace:\n\n```cpp\nNice n1;\n```\nThe default constructor Nice() is called.\na is set to 0.\nNo output yet.\n\n\n```cpp\nn1.setA(15);\n```\nThe value of a in n1 is set to 15.\nNo output yet.\n\n```cpp\nshow(n1);\n```\nThe function show(Nice &obj) is called.\nThe argument n1 is passed by reference, so no copy constructor is called.\nInside show(), obj.getA() is called, which returns 15.\nThe output is:\n``cpp\nI am the show function, value is: 15\n``\nKey Point:\n\nThe copy constructor is not called because n1 is passed by reference to show(), not by value.\nIf show() accepted Nice obj (by value), the copy constructor would be called.",
    "page": 0,
    "updated_at": "2025-08-16T00:17:21.034980"
  },
  {
    "id": 48,
    "question": "If we did not specify a constructor to the class, then :",
    "options": [
      {
        "id": "A",
        "text": "we won't be able to create object of class"
      },
      {
        "id": "B",
        "text": "we won't be able to create object of class, and compiler will give compilation error"
      },
      {
        "id": "C",
        "text": "we won't be able to create object of class, and compiler will give warning"
      },
      {
        "id": "D",
        "text": "it will generate run-time error"
      },
      {
        "id": "E",
        "text": "None of the above"
      }
    ],
    "correct_answer": "E",
    "explanation": "If you do not define any constructors for a class, the compiler will automatically generate a public default (no-argument) constructor for you. This allows you to create objects of the class without any error. Therefore, none of the other statements are correct.\n ```img\nhttps://i.postimg.cc/RFjG8J6N/image.png\n ```\n ```cpp\n#include <iostream>\nusing namespace std;\n\nclass MyClass {\npublic:\n    int x;\n    void print() {\n        cout << \"x = \" << x << endl;\n    }\n};\n\nint main() {\n    MyClass obj; // ÙŠØ¹Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù…Ø´ÙƒÙ„Ø© Ø¨ÙØ¶Ù„ Ø§Ù„Ù€ default constructor\n    obj.x = 10;\n    obj.print();\n    return 0;\n}\n```\n```cpp\nOutput : x = 10\n```\n\n```img\nhttps://i.postimg.cc/02GZWQ8y/image.png\n ```",
    "page": 0,
    "updated_at": "2025-08-20T22:21:03.173112"
  },
  {
    "id": 49,
    "question": "We can overload Destructor in the class",
    "options": [
      {
        "id": "A",
        "text": "True"
      },
      {
        "id": "B",
        "text": "False"
      }
    ],
    "correct_answer": "B",
    "explanation": "A destructor in C++ cannot be overloaded. A class can have only one destructor, which has the fixed signature `~ClassName()` and takes no parameters.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 50,
    "question": "Which two statements about constructors in C++ are true?\n\nA. A constructor can be overloaded.\nB. A constructor is a special member function with the same name as the class.\nC. A constructor can return a primitive or an object reference.\nD. All the above statements are true.",
    "options": [
      {
        "id": "A",
        "text": "C, D"
      },
      {
        "id": "B",
        "text": "A, B"
      },
      {
        "id": "C",
        "text": "A, D"
      },
      {
        "id": "D",
        "text": "B, D"
      }
    ],
    "correct_answer": "B",
    "explanation": "A. A constructor can be overloaded: True. Constructors can be overloaded by defining multiple constructors with different parameter lists in the same class, allowing different ways to initialize objects.\nB. A constructor is a special member function with the same name as the class: True. A constructor is a special member function that has the same name as the class and is automatically called when an object is created to initialize it.\nC. A constructor can return a primitive or an object reference: False. Constructors do not have a return type, not even void. They are meant to initialize objects and cannot return values.\nD. All the above: False. Since option C is false, this option is incorrect.\n\nThus, the correct choices are A and B.",
    "page": 0,
    "updated_at": "2025-08-09T18:28:05.344260"
  },
  {
    "id": 51,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Parent\n{\nprotected:\n    int x;\npublic:\n    Parent(int m) { x = m; }\n    friend void display();\n};\nclass Child: public Parent\n{\nprivate:\n    int y;\npublic:\n    Child(int m, int n): Parent(m) { y = n; }\n};\nvoid display ()\n{\n    Child c(3,4);\n    cout <<\"x=\"<<c.x<<\"y=\"<<c.y; // Line 1\n}\nvoid main ()\n{\n    display();\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Compilation Error at Line 1, Child::x is inaccessible"
      },
      {
        "id": "B",
        "text": "Compilation Error at Line 1, Child::y is inaccessible"
      },
      {
        "id": "C",
        "text": "A and B"
      },
      {
        "id": "D",
        "text": "The code compiles successfully."
      }
    ],
    "correct_answer": "B",
    "explanation": "```img\nhttps://i.postimg.cc/pX9vKgdN/image.png\n```\nFriend Function in C++\nLike friend classes, a friend function can be granted special access to private and protected members of a class in C++. They are not the member functions of the class but can access and manipulate the private and protected members of that class for they are declared as friends.\n```img\nhttps://media.geeksforgeeks.org/wp-content/uploads/20220802105339/FriendFunctioninC-660x328.png\n```\nA friend function can be:\n\nA global function\nA member function of another class\n\n1. Global Function as Friend Function\nWe can declare any global function as a friend function. The following example demonstrates how to declare a global function as a friend function in C++. The keyword â€œfriendâ€ is placed only in the function declaration of the friend function and not in the function definition or call.\n\n\nSource:https://www.geeksforgeeks.org/cpp/friend-class-function-cpp/",
    "page": 0,
    "updated_at": "2025-08-16T00:03:42.171511"
  },
  {
    "id": 52,
    "question": "\n```cpp\nclass Super\n{\nprotected:\n    Super(int a) { \n  this.a = a; // Line 1\n} \nprivate:\n    int a; // Line 2\n};\nclass Sub: public Super\n{\npublic:\n    Sub(int a):Super(a) {}\npublic:\n    Sub() { //Line 3\n        this.a= 5; //Line 4\n    }\n};\n```\n\nWhich steps will allow Sub to compile?\n\n",
    "options": [
      {
        "id": "A",
        "text": "A) Class Sub compile successfully"
      },
      {
        "id": "B",
        "text": "B) Comment Line 2"
      },
      {
        "id": "C",
        "text": "C) In Line 1 and 4, use (*this).a instead of this.a;"
      },
      {
        "id": "D",
        "text": "D) Change Line 1 and 4 to, this(a);"
      },
      {
        "id": "E",
        "text": "E) Change Line 3 to, Sub(): Super(5)"
      },
      {
        "id": "F",
        "text": "F) Change Line 3 to, Sub(): this(5)"
      },
      {
        "id": "G",
        "text": "G) All of the above"
      }
    ],
    "correct_answer": [
      "C",
      "E"
    ],
    "explanation": "```arabic\nâ€«Ù„Ø£Ù† (*this).a Ø¨ØªØµÙ„Ø­ Ø®Ø·Ø£ syntax ÙÙŠ Ø§Ù„Ø³Ø·Ø±ÙŠÙ† 1 Ùˆ4ØŒ ÙˆSub(): Super(5) Ø¨ØªØµÙ„Ø­ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ constructor ÙÙŠ Ø§Ù„Ø³Ø·Ø± 3â€¬\n```\n\n```img\nhttps://i.ibb.co/G4Lqqkz7/image.png\n```\n\n```img\nhttps://i.ibb.co/sv4pNsH9/image.png\n```\n\n```img\nhttps://i.ibb.co/BKHp7ZcY/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-10T21:10:07.414621"
  },
  {
    "id": 53,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Base\n{\npublic:\n    Base() { cout<<\"Welcome \";}\n};\nclass Derived: public Base\n{\npublic:\n    Derived() { cout<<\"Hello \"; }\n};\nvoid main()\n{\n    Base myBase;\n    Derived myDerived;\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Welcome Hello"
      },
      {
        "id": "B",
        "text": "Hello Welcome"
      },
      {
        "id": "C",
        "text": "Welcome Hello Welcome"
      },
      {
        "id": "D",
        "text": "Welcome Welcome Hello"
      }
    ],
    "correct_answer": "D",
    "explanation": "```img\nhttps://i.ibb.co/7xkRynyJ/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-10T16:14:00.498023"
  },
  {
    "id": 54,
    "question": "In order to turn a class into an abstract class, which of the following do we need to do?",
    "options": [
      {
        "id": "A",
        "text": "Write the abstract keyword before the name of the class."
      },
      {
        "id": "B",
        "text": "Make the class a pure virtual class."
      },
      {
        "id": "C",
        "text": "Write one or more pure virtual functions inside the class."
      },
      {
        "id": "D",
        "text": "A and C."
      },
      {
        "id": "E",
        "text": "None of the above"
      }
    ],
    "correct_answer": "C",
    "explanation": "The definition of an abstract class in C++ is a class that contains at least one pure virtual function. A pure virtual function is declared with the syntax `virtual return_type function_name() = 0;`.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 55,
    "question": "A protected member of a class can be directly accessed by its name inside another class if and only if that other class is a child of that class.",
    "options": [
      {
        "id": "A",
        "text": "True"
      },
      {
        "id": "B",
        "text": "False"
      }
    ],
    "correct_answer": "A",
    "explanation": "This statement is the definition of the `protected` access level. Protected members are accessible within the class that defines them and within any classes that derive from that class.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 56,
    "question": "Which of the following most closely describes the process of overriding?",
    "options": [
      {
        "id": "A",
        "text": "A class with the same name replaces the functionality of a class defined earlier in the hierarchy."
      },
      {
        "id": "B",
        "text": "A function with the same name replaces the functionality of a function defined earlier in the inheritance hierarchy."
      },
      {
        "id": "C",
        "text": "A function with the same name but different parameters gives multiple uses for the same function name."
      },
      {
        "id": "D",
        "text": "Making a class abstract so that no objects can be declared from it."
      }
    ],
    "correct_answer": "B",
    "explanation": "Function overriding occurs when a derived class provides a specific implementation for a function that is already defined in its base class. This is a key feature for achieving runtime polymorphism.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 57,
    "question": "```img\nhttps://i.postimg.cc/RV11rfTH/edit-logo.gif\n```\nAssume you have a class M that contains a pointer to an object of class N. Assume that we declare an object of M in the main() function. When will the body of the constructor of class N be executed?",
    "options": [
      {
        "id": "A",
        "text": "When any member function of the class M is called"
      },
      {
        "id": "B",
        "text": "After the body of the constructor of class M is executed"
      },
      {
        "id": "C",
        "text": "Before the body of the constructor of class M is executed"
      },
      {
        "id": "D",
        "text": "None of the above"
      }
    ],
    "correct_answer": "D",
    "explanation": "â€«Ø§Ù„Ø´Ø±Ø­: Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨ÙŠÙ‚ÙˆÙ„ Ø¥Ù† class M Ø¨ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ pointer Ù„Ù€ object Ù…Ù† class N (N* myN_ptr;). Ù…Ø¬Ø±Ø¯ ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù€ pointer Ø¯Ù‡ Ù…Ø´ Ø¨ÙŠØ¹Ù…Ù„ object.â€¬\nâ€«â€¬\nâ€«Ø§Ù„Ù€ constructor Ø¨ØªØ§Ø¹ class N Ù‡ÙŠØªÙ†ÙØ° ÙÙ‚Ø· Ù„Ùˆ Ø¹Ù…Ù„Øª new N() (Ø¹Ø´Ø§Ù† ØªØ¹Ù…Ù„ object Ù…Ù† N ÙˆØªØ®Ù„ÙŠ Ø§Ù„Ù€ pointer ÙŠØ´Ø§ÙˆØ± Ø¹Ù„ÙŠÙ‡).â€¬\nâ€«Ø§Ù„Ù€ new Ù…Ù…ÙƒÙ† ÙŠØªÙ… ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª (Ø¬ÙˆÙ‡ constructor Ø¨ØªØ§Ø¹ MØŒ Ø£Ùˆ ÙÙŠ Ø£ÙŠ member functionØŒ Ø£Ùˆ Ø­ØªÙ‰ ÙÙŠ main Ù„Ùˆ Ø§Ù„Ù€ pointer public). ÙŠØ¹Ù†ÙŠ Ù…Ø´ Ù…Ø±ØªØ¨Ø· Ø¨ÙˆÙ‚Øª Ù…Ø­Ø¯Ø¯ Ø²ÙŠ Ø§Ù„Ù€ composition Ø§Ù„Ù„ÙŠ Ø´Ø±Ø­Ù†Ø§Ù‡Ø§ ÙÙŠ Ø³Ø¤Ø§Ù„ 44.â€¬\nâ€«Ø§Ù„Ù€ A, B, C options ÙƒÙ„Ù‡Ø§ Ø¨ØªÙØªØ±Ø¶ Ø¥Ù† Ø§Ù„Ù€ object Ø¨ÙŠØªÙ†Ø´Ø£ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§.â€¬\nâ€«\n```img\nhttps://i.postimg.cc/qvssBZtB/image.png\n```\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass N {\npublic:\n    N() {\n        cout << \"N constructor called\" << endl;\n    }\n};\n\nclass M {\n    N* ptr; // Ù…Ø¤Ø´Ø± Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ N\npublic:\n    M() {\n        cout << \"M constructor called\" << endl;\n        // ptr = new N(); // Ø¥Ø°Ø§ Ø£Ø¶ÙØª Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø±ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ constructor Ø§Ù„ÙƒÙ„Ø§Ø³ N\n    }\n};\n\nint main() {\n    M obj; // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³ M\n    return 0;\n}\n```\n```cpp\nM constructor called\n```\n```img\nhttps://i.postimg.cc/fb4MCB5d/image.png\n```\n```img\nhttps://i.postimg.cc/T3gzdGqy/image.png\n```",
    "page": 0,
    "updated_at": "2025-08-20T22:44:42.434619"
  },
  {
    "id": 58,
    "question": "What will happen here\n```cpp\nclass Parent\n{\npublic:\n    int x;\n    Parent (int m) { x = m; }\n};\nclass Child: protected Parent\n{\npublic:\n    int y;\n    Child(int m, int n): Parent (m) { y=n; }\n};\nclass GrandChild: public Child\n{\n    int z;\npublic:\n    GrandChild(int a, int b, int c) : Child(a,b) { z = c; }\n};\nvoid main()\n{\n    GrandChild obj(3,5,7);\n    cout<<\"Value of x is: \"<<obj.x <<endl; //Line 1\n    cout<<\"Value of y is: \"<<obj.y <<endl; //Line 2\n    cout<<\"Value of z is: \"<<obj.z <<endl; //Line 3\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Compiler Error at Line 1"
      },
      {
        "id": "B",
        "text": "Compiler Error at Line 2"
      },
      {
        "id": "C",
        "text": "Compiler Error at Line 3"
      },
      {
        "id": "D",
        "text": "The code compiles successfully"
      }
    ],
    "correct_answer": [
      "A",
      "C"
    ],
    "explanation": "â€«ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙˆØ¯:â€¬\nâ€«â—¦ Line 1: cout << \"Value of x is: \" << obj.x;â€¬\nâ€«â€¬\nâ€«Ù€ Ù‡Ù†Ø§ Child ÙˆØ±Ø«Øª Ù…Ù† Parent Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… protected inheritanceØŒ ÙÙ€ ÙƒÙ„ Ø§Ù„Ù€ public members Ø²ÙŠ x ÙÙŠ Parent Ø¨Ù‚Øª protected Ø¬ÙˆÙ‡ Child.â€¬\nâ€«â€¬\nâ€«Ù€ Ù„Ù…Ø§ GrandChild ÙŠØ±Ø« Ù…Ù† ChildØŒ Ø§Ù„Ù€ x ØªÙØ¶Ù„ protectedØŒ ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø´ Ù…Ù…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„ÙŠÙ‡Ø§ Ù…Ù† Ø®Ø§Ø±Ø¬ Ø§Ù„ÙƒÙ„Ø§Ø³ Ø²ÙŠ Ù…Ø§ Ø¨ÙŠØ­ØµÙ„ ÙÙŠ main().â€¬\nâ€«â€¬\nâ€«Ù€ Ø§Ù„Ù†ØªÙŠØ¬Ø©: ÙŠØ­ØµÙ„ Compiler Error ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø¯Ù‡.â€¬\nâ€«â€¬\nâ€«â—¦ Line 2: cout << \"Value of y is: \" << obj.y;â€¬\nâ€«â€¬\nâ€«Ù€ Ø§Ù„Ù…ØªØºÙŠØ± y Ù…ØªØ¹Ø±Ù ÙÙŠ Child ÙƒÙ€ public.â€¬\nâ€«â€¬\nâ€«Ù€ Ù„ÙƒÙ† Child Ù†ÙØ³Ù‡Ø§ ÙˆØ±Ø«Øª Ù…Ù† Parent Ø¨Ù€ protectedØŒ ÙˆØ¯Ù‡ Ù…Ø§ÙŠØ£Ø«Ø±Ø´ Ø¹Ù„Ù‰ y Ù„Ø£Ù†Ù‡Ø§ Ù…ØªØ¹Ø±ÙÙ‡ Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ Child.â€¬\nâ€«â€¬\nâ€«Ù€ Ù„Ù…Ø§ GrandChild ÙŠØ±Ø« Ù…Ù† Child Ø¨Ù€ publicØŒ ÙŠÙ‚Ø¯Ø± ÙŠØ³ØªØ®Ø¯Ù… y Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ.â€¬\nâ€«â€¬\nâ€«Ù€ Ø§Ù„Ù†ØªÙŠØ¬Ø©: Ø§Ù„Ø³Ø·Ø± Ø¯Ù‡ ÙŠØ´ØªØºÙ„ ØªÙ…Ø§Ù… ÙˆÙ…ÙÙŠØ´ Ø®Ø·Ø£.â€¬\nâ€«â€¬\nâ€«â—¦ Line 3: cout << \"Value of z is: \" << obj.z;â€¬\nâ€«â€¬\nâ€«Ù€ Ø§Ù„Ù…ØªØºÙŠØ± z Ù…ØªØ¹Ø±Ù ÙÙŠ GrandChild ÙƒÙ€ private.â€¬\nâ€«â€¬\nâ€«Ù€ ÙˆØ¯Ù‡ Ù…Ø¹Ù†Ø§Ù‡ Ø¥Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ù„ÙŠÙ‡ Ù…Ù† Ø®Ø§Ø±Ø¬ Ø§Ù„ÙƒÙ„Ø§Ø³ (Ø²ÙŠ main()) Ù…Ø´ Ù…Ø³Ù…ÙˆØ­.â€¬\nâ€«â€¬\nâ€«Ù€ Ø§Ù„Ù†ØªÙŠØ¬Ø©: ÙŠØ­ØµÙ„ Compiler Error ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø¯Ù‡.â€¬\nâ€«â€¬\nâ€«âœ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:â€¬\nâ€«âŒ Compiler Error at Line 1â€¬\nâ€«â€¬\nâ€«âœ… Line 2 works fineâ€¬\nâ€«â€¬\nâ€«âŒ Compiler Error at Line 3â€¬\nâ€«â€¬\nâ€«ÙŠØ¹Ù†ÙŠ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØµØ­ÛŒØ­Ø© Ù‡ÙŠ: A Ùˆ C Ù„Ø£Ù† Ø§Ù„Ø³Ø·Ø±ÙŠÙ† 1 Ùˆ 3 Ù‡ÙŠØ·Ù„Ø¹ÙˆØ§ ÙÙŠÙ‡Ù… Ø£Ø®Ø·Ø§Ø¡.â€¬",
    "page": 0,
    "updated_at": "2025-08-20T23:07:41.153346"
  },
  {
    "id": 59,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Tester\n{\npublic:\n    int x;\n    static int var;\n    Tester(int a) { x = a; }\n    static void myFunction(int a)\n    {\n        Tester obj(9);    // Line 1\n        obj.x=a;         // Line 2\n        cout<<obj.x;\n    }\n};\nint Tester::var=0;\nvoid main()\n{\n    Tester myT(7);\n    Tester::myFunction(15);\n    cout<<myT.x;\n    cout<<Tester::var<<endl; // Line 3\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "15 7 0"
      },
      {
        "id": "B",
        "text": "7 15 0"
      },
      {
        "id": "C",
        "text": "15 9 0"
      },
      {
        "id": "D",
        "text": "9 15 0"
      },
      {
        "id": "E",
        "text": "Compilation error at line 1"
      },
      {
        "id": "F",
        "text": "Compilation error at line 2"
      },
      {
        "id": "G",
        "text": "Compilation error at line 3"
      },
      {
        "id": "H",
        "text": "None of the above"
      }
    ],
    "correct_answer": "A",
    "explanation": "1. `Tester myT(7);`: Creates an object `myT` with `myT.x` equal to 7.\n2. `Tester::myFunction(15);`: Calls the static function. Inside, a *local* object `obj` is created and its `x` is set to 15. The function then prints `obj.x`, which is `15`.\n3. `cout<<myT.x;`: Back in `main`, `myT` was unaffected by the static function call. Its `x` is still 7. This line prints `7`.\n4. `cout<<Tester::var<<endl;`: The static variable `var` was initialized to 0 and never changed. This line prints `0`.\nThe combined output is `1570`.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 60,
    "question": "The term \" Composition \" refers to an object of a class that contains another object of another class inside it.",
    "options": [
      {
        "id": "A",
        "text": "True"
      },
      {
        "id": "B",
        "text": "False"
      }
    ],
    "correct_answer": "A",
    "explanation": "This statement is a correct definition of composition. It describes a 'has-a' relationship where an object is 'composed' of other objects, which are included as member variables.",
    "page": 0,
    "updated_at": "2025-08-09T16:52:54.855122"
  },
  {
    "id": 61,
    "question": "Which of the following is true about an object member function?",
    "options": [
      {
        "id": "A",
        "text": "It can be called using the name of the class."
      },
      {
        "id": "B",
        "text": "It can access static variables of the class."
      },
      {
        "id": "C",
        "text": "It has a this pointer as an implicit parameter passed to it"
      },
      {
        "id": "D",
        "text": "It can access the instance variables."
      },
      {
        "id": "E",
        "text": "It cannot be overloaded."
      },
      {
        "id": "F",
        "text": "It can call other member functions from inside it."
      }
    ],
    "correct_answer": [
      "B",
      "C",
      "D",
      "F"
    ],
    "explanation": "Option A: \"It can be called using the name of the class.\"\nThis is false. Non-static member functions require an object instance for invocation (e.g., obj.function()). Only static member functions can be called with the class name (e.g., ClassName::staticFunction()).\nOption B: \"It can access static variables of the class.\"\nThis is true. Non-static member functions can access static variables because static variables belong to the class and are accessible to all member functions (both static and non-static).\nExample:\n```cpp\nclass Example {\n    static int staticVar;\n    void nonStaticFunc() {\n        staticVar = 42; // Valid: non-static member function accesses static variable\n    }\n};\n```\nOption C: \"It has a 'this' pointer as an implicit parameter passed to it.\"\nThis is true. Non-static member functions implicitly receive a this pointer, which points to the current object instance. This is a fundamental characteristic of object member functions.\nExample (implicit this usage):\n```cpp\nclass Example {\n    int value;\n    void set(int v) {\n        this->value = v; // 'this' is implicitly available\n    }\n};\n```\nOption D: \"It can access the instance variables.\"\nThis is true. Non-static member functions can access instance variables (non-static data members) because they operate on a specific object instance (via the this pointer).\nExample:\n```cpp\nclass Example {\n    int instanceVar;\n    void modify() {\n        instanceVar = 10; // Valid: accesses instance variable\n    }\n};\n```\nOption E: \"It cannot be overloaded.\"\nThis is false. Non-static member functions can be overloaded based on parameter types/number, just like other functions.\nExample:\n```cpp\nclass Example {\n    void func(int x); // Overload #1\n    void func(double x); // Overload #2 (valid)\n};\n```\nOption F: \"It can call other member functions from inside it.\"\nThis is true. Non-static member functions can call other member functions (both static and non-static) of the same class.\nExample:\n```cpp\nclass Example {\n    void func1() { }\n    void func2() {\n        func1(); // Valid: calls another member function\n    }\n};\n```",
    "page": 0,
    "updated_at": "2025-08-15T23:10:08.954023"
  },
  {
    "id": 62,
    "question": "Which of the following is true about the function prototype below?\n```cpp\nvoid myFunc (int myDef=17, int myVar, int myNormalVar=5);\n``` ",
    "options": [
      {
        "id": "A",
        "text": "We should also give a default value to myVar."
      },
      {
        "id": "B",
        "text": "We must only give a default parameter for myNormalVar and not the others"
      },
      {
        "id": "C",
        "text": "The function is correct in that way"
      }
    ],
    "correct_answer": "A",
    "explanation": "â€«Ø§Ù„Ù€ prototype: void myFunc (int myDef=17, int myVar, int myNormalVar=5); ØºÙŠØ± ØµØ­ÙŠØ­.â€¬\nâ€«Ø§Ù„Ø³Ø¨Ø¨: ÙÙŠ C++ØŒ Ø¥Ø°Ø§ Ø£Ø¹Ø·ÙŠØª Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (default value) Ù„Ø£ÙŠ Ø¨Ø§Ø±Ø§Ù…ØªØ±ØŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† ÙƒÙ„ Ø§Ù„Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª Ø§Ù„ØªÙŠ ØªÙ„ÙŠÙ‡ Ù„Ù‡Ø§ Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø£ÙŠØ¶Ù‹Ø§. Ù‡Ù†Ø§ØŒ myDef Ù„Ù‡ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (17)ØŒ Ù„ÙƒÙ† myVar Ù„ÙŠØ³ Ù„Ù‡ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©ØŒ Ø¨ÙŠÙ†Ù…Ø§ myNormalVar Ù„Ù‡ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (5).â€¬\nâ€«Ø§Ù„Ø­Ù„: ÙŠØ¬Ø¨ Ø¥Ø¹Ø·Ø§Ø¡ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù€ myVar Ø£ÙŠØ¶Ù‹Ø§ (Ù…Ø«Ù„: int myVar=0) Ø£Ùˆ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù…Ù† myDef.â€¬\nâ€«Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: \"We should also give a default value to myVar\".â€¬\nâ€«â€¬\nâ€«â€¬",
    "page": 0,
    "updated_at": "2025-08-09T19:14:47.939591"
  },
  {
    "id": 63,
    "question": "Static member variable can only be modified through static member functions.",
    "options": [
      {
        "id": "A",
        "text": "True"
      },
      {
        "id": "B",
        "text": "False"
      }
    ],
    "correct_answer": "B",
    "explanation": "This statement is false. A static member variable belongs to the class, not an individual object, and can be accessed and modified by both static member functions and non-static member functions.\n\nâ€«â€¢ Ø§Ù„Ø´Ø±Ø­: Ø§Ù„Ù€  static member variableØ¨ØªÙ†ØªÙ…ÙŠ Ù„Ù„Ù€  classÙƒÙ„Ù‡ØŒ Ù…Ø´ Ù„Ù€  objectÙØ±Ø¯ÙŠ Ù…Ø¹ÛŒÙ†. Ø¹Ø´Ø§Ù† ÙƒØ¯Ù‡ØŒ ØªÙ‚Ø¯Ø±â€¬\nâ€«non-static member functions  Ø£Ùˆ Ù…Ù† Ø®Ù„Ø§Ù„static member functions ØªÙˆØµÙ„Ù‡Ø§ ÙˆØªØ¹Ø¯Ù„Ù‡Ø§ Ù…Ù† Ø®Ù„Ø§Ù„â€¬\nâ€«Ø¹Ø§Ø¯ÙŠâ€¬",
    "page": 0,
    "updated_at": "2025-08-20T23:39:18.547333"
  },
  {
    "id": 64,
    "question": "what shall we add to the above class Stack to declare another object s2 from class Stack where s2 is declared in terms of s1; `Stack s2(s1)`?\n```cpp\nclass Stack\n{\n    int tos,size;\n    int * st;\n    Stack(int s=5) { tos=0;size=s; st=new int[size];}\n    ~Stack(){ delete []st;}\n};\nvoid main()\n{\n    Stack s1(20);\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "We must specify overload of assignment operator for class Stack."
      },
      {
        "id": "B",
        "text": "We must define a copy constructor to class Stack"
      },
      {
        "id": "C",
        "text": "A and B"
      },
      {
        "id": "D",
        "text": "This situation cannot be achieved in C++, however, it has been solved in other programming languages."
      }
    ],
    "correct_answer": "B",
    "explanation": "specify the way of declared Stack s2(s1) // only call cpy ctor\n\nThe syntax `Stack s2(s1);` is initialization, which invokes the copy constructor. Since the `Stack` class manages a raw pointer (`st`), the default, compiler-generated copy constructor would perform a shallow copy, leading to a double-free error. To handle this correctly, a user-defined copy constructor must be implemented to perform a deep copy (allocating new memory for `s2.st`).\n\n\nâ€«â€¢ Ø§Ù„Ø´Ø±Ø­: Ø§Ù„Ø³Ø·Ø±  ;(Stack s2(s1Ù‡Ùˆ Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù†  initializationÙ„Ù€  objectØ¬Ø¯ÛŒØ¯ ) (s2Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…  objectÙ…ÙˆØ¬ÙˆØ¯â€¬\nâ€«.\"copy constructor\" (ØŒ ÙˆØ¯Ù‡ Ø¨ÛŒØ´ØºÙ„ Ø§Ù„Ù€s1)â€¬\nâ€«â—¦ Ø§Ù„Ù€  Stack classØ¨ÛŒØ³ØªØ®Ø¯Ù…  (raw pointer (stØ¹Ø´Ø§Ù† ÛŒØ¯ÛŒØ± Ø°Ø§ÙƒØ±Ø© Ø¯ÛŒÙ†Ø§Ù…ÛŒÙƒÛŒØ© ).([new int[sizeâ€¬\nâ€«\" Ø£ÙˆØªÙˆÙ…Ø§ØªÛŒÙƒÙŠ. Ø§Ù„Ù€default copy constructor\"  Ø¨ÛŒØ¹Ù…Ù„compiler  Ù…Ø¹Ø±ÙØŒ Ø§Ù„Ù€copy constructor â—¦ Ù„Ùˆ Ù…ÙÛŒØ´â€¬\nâ€« default copy constructorØ¯Ù‡ Ø¨ÛŒØ¹Ù…Ù„ \" .\"shallow copyÛŒØ¹Ù†ÙŠ Ø¨Ø¯Ù„ Ù…Ø§ ÛŒÙ†Ø³Ø® Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù„ÙŠ Ø§Ù„Ù€  pointerØ¨ÛŒØ´Ø§ÙˆØ±â€¬\nâ€«Ø¹Ù„ÛŒÙ‡Ø§ØŒ Ù‡Ùˆ Ø¨Ø³ Ø¨ÛŒÙ†Ø³Ø® Ù‚ÛŒÙ…Ø© Ø§Ù„Ù€  pointerÙ†ÙØ³Ù‡. Ø¯Ù‡ Ù…Ø¹Ù†Ø§Ù‡ Ø¥Ù†  s1.stÙˆ  s2.stØ§Ù„Ø§ØªÙ†ÛŒÙ† Ù‡ÛŒØ´Ø§ÙˆØ±ÙˆØ§ Ø¹Ù„Ù‰ Ù†ÙØ³ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©.â€¬\nâ€«â—¦ Ù„Ù…Ø§ Ø§Ù„Ù€  objectsØ¯ÙˆÙ„ ÛŒØªÙ… ØªØ¯Ù…ÛŒØ±Ù‡Ù…ØŒ Ø§Ù„Ù€  (()destructor (~StackÙ‡ÛŒØ­Ø§ÙˆÙ„ ÛŒØ¹Ù…Ù„ ;delete []stÙ…Ø±ØªÛŒÙ† Ù„Ù†ÙØ³â€¬\nâ€«Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©ØŒ ÙˆØ¯Ù‡ Ø¨ÛŒØ³Ø¨Ø¨ \".\"double-free errorâ€¬\nâ€«copy \". ÛŒØ¹Ù†ÙŠ Ø§Ù„Ù€deep copy\"  Ø¹Ø´Ø§Ù† ØªØ¹Ù…Ù„user-defined copy constructor â€¢ Ø¹Ø´Ø§Ù† ÙƒØ¯Ù‡ØŒ Ù„Ø§Ø²Ù… ØªØ¹Ù…Ù„â€¬\nâ€« constructorØ§Ù„Ø¬Ø¯ÛŒØ¯ Ø¯Ù‡ Ù‡ÛŒØ®ØµØµ Ø°Ø§ÙƒØ±Ø© Ø¬Ø¯ÛŒØ¯Ø© Ù„Ù€  s2.stÙˆÛŒÙ†Ø³Ø® ÙÛŒÙ‡Ø§ Ù…Ø­ØªÙˆÛŒØ§Øª .â€¬\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Stack\n{\n    int tos, size;\n    int *st;\npublic:\n    Stack(int s=5) { tos=0; size=s; st=new int[size]; }\n    ~Stack() { delete []st; }\n    // Ø¥Ø¶Ø§ÙØ© copy constructor\n    Stack(const Stack& other) {\n        tos = other.tos;\n        size = other.size;\n        st = new int[size];\n        for (int i = 0; i < tos; i++) {\n            st[i] = other.st[i];\n        }\n    }\n};\n\nint main() // ØªØµØ­ÙŠØ­ Ø¥Ù„Ù‰ int main\n{\n    Stack s1(20);\n    Stack s2(s1); // ÙŠØ³ØªØ¯Ø¹ÙŠ copy constructor\n    return 0;\n}\n```",
    "page": 0,
    "updated_at": "2025-08-20T23:44:23.729981"
  },
  {
    "id": 65,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Parent\n{\n    int x;\n    Parent(int m){ x = m; }\n};\nclass Child: public Parent\n{ \npublic:\n    int y;\n    Child(int m, int n): Parent(m) //Line 1\n    { y = n; }\n};\nvoid main()\n{\n    Child obj(3,5,7);         //Line 2\n    cout<<\"Value of x is: \"<<obj.x <<endl; //Line 3\n    cout<<\"Value of y is: \"<<obj.y <<endl; //Line 4\n}\n```\n",
    "options": [
      {
        "id": "A",
        "text": "A. Compiler Error at Line 1"
      },
      {
        "id": "B",
        "text": "B. Compiler Error at Line 2"
      },
      {
        "id": "C",
        "text": "C. Compiler Error at Line 3"
      }
    ],
    "correct_answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "```img\nhttps://i.postimg.cc/2ST06tFM/image.png\n```\nErrors in Our Code:\n\n\nLine 1 (Constructor Access):\n\nError: 'Parent::Parent(int)' is private within this context\nCause: The Parent constructor is private (since no access specifier is given for the class), so the Child class cannot call it.\nLocation: Line 14 in the constructor of Child.\n\n\n\nLine 2 (Argument Mismatch):\n\nError: no matching function for call to 'Child::Child(int, int, int)'\nCause: The Child constructor is called with 3 arguments, but it only accepts 2.\nLocation: Line 21 in main().\n\n\n\nLine 3 (Private Member Access):\n\nError: 'int Parent::x' is private within this context\nCause: x is a private member of Parent, so obj.x cannot be accessed in main().\nLocation: Line 22 in main().\n\n",
    "page": 0,
    "updated_at": "2025-08-15T23:31:41.331359"
  },
  {
    "id": 66,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Parent\n{\nprotected:\n    int myVar;\npublic:\n    Parent(int x) { myVar=x; }\n    void powerTwo(){ cout<<myVar*myVar; }\n    virtual void powerThree() { cout <<myVar*myVar*myVar; }\n};\nclass Child:public Parent\n{\nprotected:\n    int myData;\npublic:\n    Child(int a, int b): Parent(a) {myData= b;}\n    void powerTwo() { cout <<myData*myData; }\n    void powerThree() { cout<<myData*myData*myData; }\n};\nvoid main()\n{\n    Child myCh(2,3);\n    Parent *myPtr;\n    myPtr = &myCh;\n    myPtr->powerTwo(); //Line1\n    myPtr->powerThree(); //Line 2\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "4 8"
      },
      {
        "id": "B",
        "text": "4 27"
      },
      {
        "id": "C",
        "text": "9 27"
      },
      {
        "id": "D",
        "text": "9 8"
      },
      {
        "id": "E",
        "text": "Compilation Error at Line1"
      }
    ],
    "correct_answer": "B",
    "explanation": "A Child object myCh is created with values 2 and 3. This means:\nThe Parent part of the object has myVar = 2\nThe Child part has myData = 3\nA Parent pointer myPtr is set to point to the Child object.\nFor myPtr->powerTwo() (Line 1):\npowerTwo() is NOT a virtual method\nWhen calling a non-virtual method through a base class pointer, the method from the pointer's class is used\nSo Parent::powerTwo() executes, printing myVar * myVar = 2 * 2 = 4\nFor myPtr->powerThree() (Line 2):\npowerThree() IS a virtual method\nWhen calling a virtual method through a base class pointer, the method from the actual object's class is used (polymorphism)\nSo Child::powerThree() executes, printing myData * myData * myData = 3 * 3 * 3 = 27\nThis demonstrates the key difference between virtual and non-virtual methods in C++ inheritance - virtual methods enable runtime polymorphism while non-virtual methods are resolved at compile time based on the pointer type.",
    "page": 0,
    "updated_at": "2025-08-10T16:29:16.536110"
  },
  {
    "id": 67,
    "question": "What will be the output when you compile and run the following piece of code?\n```cpp\nclass Parent\n{ \n    int y;\n    static int z;\npublic:\n    Parent()\n    {\n        z=0; // Line1\n    }\n    Parent (int a=5) //Line 2\n    {\n        y=a;\n    }\n};\nvoid main()\n{\n    Parent d(4);   //Line 3\n    Parent m;      //Line 4\n}\n```",
    "options": [
      {
        "id": "A",
        "text": "Compilation Error at Line 1, an object member function cannot access a static member"
      },
      {
        "id": "B",
        "text": "Compilation Error at Line 2, constructor should initialize static member (z=0;)"
      },
      {
        "id": "C",
        "text": "Compilation Error at Line 3"
      },
      {
        "id": "D",
        "text": "Compilation Error at Line 4."
      },
      {
        "id": "E",
        "text": "The code compiles successfully."
      }
    ],
    "correct_answer": "D",
    "explanation": "```img\nhttps://i.postimg.cc/Hnh7RQQS/image.png\n```\n\nâ€¬â€«ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©:â€¬\nâ€«â—¦ Line 1: static int z;â€¬\nâ€«Ø§Ù„Ù…ØªØºÙŠØ± z Ù…ØªØ¹Ø±Ù ÙƒÙ€ static member.â€¬\nâ€«â€¬\nâ€«ÙÙŠ C++ØŒ Ù„Ø§Ø²Ù… ØªØ¹Ù…Ù„ initialization Ù„Ù„Ù€ static member Ø®Ø§Ø±Ø¬ Ø§Ù„ÙƒÙ„Ø§Ø³ØŒ Ù…Ø´ Ø¬ÙˆÙ‡ Ø§Ù„Ù€ constructor.â€¬\nâ€«â€¬\nâ€«ÙŠØ¹Ù†ÙŠ Ù„Ùˆ ÙƒØªØ¨Øª z = 0; Ø¬ÙˆÙ‡ Ø§Ù„Ù€ constructorØŒ Ø¯ÙŠ Ù…Ø´ Ø·Ø±ÙŠÙ‚Ø© ØµØ­ÙŠØ­Ø© Ù„Ù„ØªÙ‡ÙŠØ¦Ø©ØŒ Ù„ÙƒÙ† Ù…Ø´ Ù‡ÙŠ Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ù€ error Ù‡Ù†Ø§.â€¬\nâ€«â€¬\nâ€«â—¦ Line 4: Parent m;â€¬\nâ€«Ù‡Ù†Ø§ Ø¨ØªØ­Ø§ÙˆÙ„ ØªÙ†Ø´Ø¦ ÙƒØ§Ø¦Ù† Ù…Ù† Parent Ø¨Ø¯ÙˆÙ† ØªÙ…Ø±ÙŠØ± Ø£ÙŠ arguments.â€¬\nâ€«â€¬\nâ€«Ù„ÙƒÙ† Ø§Ù„ÙƒÙ„Ø§Ø³ Parent ÙÙŠÙ‡ constructor Ø¨Ø§Ù„Ø´ÙƒÙ„ Ø¯Ù‡:â€¬\nâ€«â€¬\nâ€«cpp```â€¬\nâ€«Parent(int a = 5)\n```\nâ€«Ø¯Ù‡ Ù…Ø¹Ù†Ø§Ù‡ Ø¥Ù† ÙÙŠÙ‡ default valueØŒ ÙÙ€ Ø§Ù„Ù…ÙØ±ÙˆØ¶ Ø¥Ù† Ø§Ù„Ù€ compiler ÙŠÙ‚Ø¯Ø± ÙŠÙ†Ø´Ø¦ Ø§Ù„ÙƒØ§Ø¦Ù† Ø¨Ø¯ÙˆÙ† Ù…Ø´Ø§ÙƒÙ„.â€¬\nâ€«â€¬\nâ€«Ù„ÙƒÙ† Ù„Ùˆ Ø§Ù„Ù€ constructor Ù…ÙƒØªÙˆØ¨ ÙƒØ¯Ù‡:â€¬\nâ€«â€¬\n```â€«cppâ€¬\nâ€«Parent(int a)\n```\nâ€«Ù…Ù† ØºÙŠØ± default valueØŒ ÙÙ€ Ù„Ù…Ø§ ØªÙƒØªØ¨ Parent m;ØŒ Ø§Ù„Ù€ compiler Ù‡ÙŠØ­Ø§ÙˆÙ„ ÙŠÙ†Ø¯Ù‡ default constructorØŒ ÙˆØ§Ù„Ù„ÙŠ Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ØŒ ÙÙ€ ÙŠØ­ØµÙ„ Compilation Error.â€¬\nâ€«â€¬\nâ€«âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø© Ù…Ù‡Ù…Ø©:â€¬\nâ€«Ø§Ù„Ù€ static member z Ù„Ø§Ø²Ù… ÙŠØªØ¹Ù…Ù„Ù‡ initialization Ø¨Ø§Ù„Ø´ÙƒÙ„ Ø¯Ù‡ Ø®Ø§Ø±Ø¬ Ø§Ù„ÙƒÙ„Ø§Ø³:â€¬\nâ€«â€¬\n```â€«cppâ€¬\nâ€«int ClassName::z = 0\n```;â€¬\nâ€«Ù„ÙƒÙ† Ø¯Ù‡ Ù…Ø´ Ù‡ÙŠÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ Ù„Ùˆ Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ØŒ Ø¥Ù„Ø§ Ù„Ùˆ Ø­Ø§ÙˆÙ„Øª ØªØ³ØªØ®Ø¯Ù… z Ù‚Ø¨Ù„ Ù…Ø§ ØªÙ‡ÙŠØ¦Ù‡.â€¬\nâ€«â€¬\nâ€«âœ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:â€¬\nâ€«D. Compilation Error at Line 4â€¬\nâ€«â€¬\nâ€«Ø¨Ø³Ø¨Ø¨ Ø¥Ù† Ø§Ù„Ù€ constructor Ø§Ù„Ù„ÙŠ Ø§Ù„Ù…ÙØ±ÙˆØ¶ ÙŠØ³ØªÙ‚Ø¨Ù„ parameter Ù…Ø´ Ù…ØªÙˆÙØ± Ø¨Ø¯ÙˆÙ† argumentsØŒ ÙˆØ§Ù„Ù€ compiler Ù…Ø´ Ù‡ÙŠÙ‚Ø¯Ø± ÙŠÙ†Ø´Ø¦ Ø§Ù„ÙƒØ§Ø¦Ù† Parent m;.\n\nfixed code after initialize static by removing default parameters\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Parent\n{\n    int y;\n    static int z;\npublic:\n    Parent()\n    {\n        z=0; // Line1\n    }\n    Parent (int a) //Line 2\n    {\n        y=a;\n    }\n};\n// Static member initialization outside the class\nint Parent::z = 0;\nint main()\n{\n    Parent d(4);   //Line 3\n    Parent m;      //Line 4\n    return 0;\n}\nâ€¬```",
    "page": 0,
    "updated_at": "2025-08-21T00:14:58.012567"
  },
  {
    "id": 68,
    "question": "If a programmer does not declare a constructor for a certain class, then\nthe compiler will automatically create a default constructor for that class. ",
    "options": [
      {
        "id": "A",
        "text": "true"
      },
      {
        "id": "B",
        "text": "false"
      }
    ],
    "correct_answer": "A",
    "explanation": "TRUE",
    "created_at": "2025-08-09T23:17:53.174516",
    "page": 0
  },
  {
    "id": 293,
    "question": "Design and implement the following using C++ Programming Language\n\n25. ITI is an educational institute consists of students. Each of them studies some subjects that may differ from student to another and can be changed. Also, it has a staff that teaches these subjects.\n\n1. Extract the classes from the last sentences (5 Marks) 2. State their relation between them (4 Marks) 3. Implement the above classes (5 Marks) 4. Design and Implement a new class named ITI that consists of number of people (Student and/or Staff) (5 Marks) 5. Make a member function in the ITI that prints all people data. (6 Marks)\n\n(25 Points)\n\nDo NOT refer to the image by its URL.",
    "options": [
      {
        "id": "A",
        "text": "View Answer"
      },
      {
        "id": "B",
        "text": "View Answer"
      }
    ],
    "correct_answer": "A",
    "explanation": "\"ITI is an educational institute consists of students. Each of them studies some subjects that may differ from student to another and can be changed. Also, it has a staff that teaches these subjects.\"\n\nâ€«Ù…Ù† Ø§Ù„Ø¬Ù…Ù„Ø© Ø¯ÙŠ Ù†Ù‚Ø¯Ø± Ù†Ø³ØªÙ†ØªØ¬ Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:\nâ€¬```img\nhttps://i.postimg.cc/DzYgDvxJ/image.png\n```\nâ€«âœ³ï¸ 2. Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øªâ€¬\nâ€¬```img\nhttps://i.postimg.cc/1XDrfpsw-/image.png\n```\nâ€«âœ³ï¸ 3. ØªÙ†ÙÙŠØ° Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øªâ€¬\nâ€«Ø£Ù†Øª Ø¨Ø§Ù„ÙØ¹Ù„ Ù†ÙØ°ØªÙ‡Ø§ Ø¨Ø´ÙƒÙ„ Ù…Ù…ØªØ§Ø² ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠ ÙƒØªØ¨ØªÙ‡ØŒ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø¨Ø¹Ø¶ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù„ÙŠ Ø°ÙƒØ±ØªÙ‡Ø§ Ù„Ùƒ Ù‚Ø¨Ù„ ÙƒØ¯Ù‡ (Ø²ÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… std::string Ø¨Ø¯Ù„ char[]).â€¬\n\nâ€«âœ³ï¸ 4. ØªØµÙ…ÙŠÙ… ÙˆØªÙ†ÙÙŠØ° ÙƒÙ„Ø§Ø³ ITIâ€¬\nâ€«ÙƒÙ„Ø§Ø³ ITI ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù…Ù† Person* (ÙŠØ¹Ù†ÙŠ Ù…Ù…ÙƒÙ† ØªÙƒÙˆÙ† Student Ø£Ùˆ Staff) ÙˆØ¨ÙŠØ®Ø²Ù† Ø¹Ø¯Ø¯Ù‡Ù…. ØªÙ… ØªÙ†ÙÙŠØ°Ù‡ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ ÙƒØ§Ù„ØªØ§Ù„ÙŠ:â€¬\n```cpp\nclass ITI {\n  Person** People;\n  int count;\n  ...\n};\n```\nâ€«âœ³ï¸ 5. Ø¯Ø§Ù„Ø© Ù„Ø·Ø¨Ø§Ø¹Ø© Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ„ Ø§Ù„Ø£Ø´Ø®Ø§Øµâ€¬\nâ€«Ø§Ù„Ø¯Ø§Ù„Ø© PrintAllPeopleInfo() ÙÙŠ ÙƒÙ„Ø§Ø³ ITI Ø¨ØªØ·Ø¨Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ„ Ø´Ø®Øµ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© PrintInfo():â€¬\n```cpp\nvoid PrintAllPeopleInfo() {\n  for(int i=0; i<count; i++) {\n    People[i]->PrintInfo();\n  }\n}\n```\nâ€«ÙØ£Ù†Ø§ Ù‡Ù‚Ø¯Ù…Ù„Ùƒ Ù†Ø³Ø®Ø© ÙƒØ§Ù…Ù„Ø© ÙˆÙ…ÙØ­Ø³Ù‘Ù†Ø© Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ­Ù‚Ù‚ ÙƒÙ„ Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù„ÙŠ ÙÙŠ ØµÙˆØ±Ø© Ø§Ù„ÙˆØ§Ø¬Ø¨ØŒ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„ØªÙ†Ø¸ÙŠÙ…ØŒ Ø§Ù„Ø£Ù…Ø§Ù†ØŒ ÙˆØ§Ù„ÙˆØ¶ÙˆØ­ ÙÙŠ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©. Ù‡Ù†Ø³ØªØ®Ø¯Ù… std::string Ø¨Ø¯Ù„ char[] Ù„ØªÙØ§Ø¯ÙŠ Ù…Ø´Ø§ÙƒÙ„ overflowØŒ ÙˆÙ‡Ù†Ø¯Ù…Ø¬ ÙƒÙ„ Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:â€¬\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// âœ… ÙƒÙ„Ø§Ø³ Subject\nclass Subject {\n    string name;\npublic:\n    Subject() {}\n    Subject(string n) : name(n) {}\n    string GetName() { return name; }\n    void SetName(string n) { name = n; }\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ Person (Ø£Ø³Ø§Ø³ÙŠ ÙˆÙ…Ø¬Ø±Ø¯)\nclass Person {\nprotected:\n    string name;\npublic:\n    Person(string n) : name(n) {}\n    string GetName() { return name; }\n    void SetName(string n) { name = n; }\n    virtual void PrintInfo() = 0; // Ø¯Ø§Ù„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ Student\nclass Student : public Person {\n    Subject subjects[7];\n    int subjectCount;\npublic:\n    Student(string n) : Person(n), subjectCount(0) {}\n\n    Student(string n, string subjectNames[], int count) : Person(n) {\n        if (count <= 7) {\n            subjectCount = count;\n            for (int i = 0; i < count; ++i)\n                subjects[i].SetName(subjectNames[i]);\n        } else {\n            cout << \"âŒ Can't add more than 7 subjects.\\n\";\n            subjectCount = 0;\n        }\n    }\n\n    void AddSubject(string subjectName) {\n        if (subjectCount < 7)\n            subjects[subjectCount++].SetName(subjectName);\n        else\n            cout << \"âŒ Student can't have more than 7 subjects.\\n\";\n    }\n\n    void SetSubject(string subjectName, int index) {\n        if (index < subjectCount)\n            subjects[index].SetName(subjectName);\n        else\n            cout << \"âŒ Subject index out of range.\\n\";\n    }\n\n    void PrintInfo() override {\n        cout << \"ğŸ‘¤ Name: \" << name << \"\\nğŸ”° Role: Student\\n\";\n        if (subjectCount == 0)\n            cout << \"ğŸ“š No subjects enrolled.\\n\";\n        else {\n            for (int i = 0; i < subjectCount; ++i)\n                cout << \"ğŸ“˜ Subject \" << i + 1 << \": \" << subjects[i].GetName() << \"\\n\";\n        }\n        cout << \"----------------------------------------\\n\";\n    }\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ Staff\nclass Staff : public Person {\n    Subject subjects[3];\n    int taughtCount;\npublic:\n    Staff(string n) : Person(n), taughtCount(0) {}\n\n    Staff(string n, string subjectNames[], int count) : Person(n) {\n        if (count <= 3) {\n            taughtCount = count;\n            for (int i = 0; i < count; ++i)\n                subjects[i].SetName(subjectNames[i]);\n        } else {\n            cout << \"âŒ Can't teach more than 3 subjects.\\n\";\n            taughtCount = 0;\n        }\n    }\n\n    void AddSubject(string subjectName) {\n        if (taughtCount < 3)\n            subjects[taughtCount++].SetName(subjectName);\n        else\n            cout << \"âŒ Staff can't teach more than 3 subjects.\\n\";\n    }\n\n    void SetSubject(string subjectName, int index) {\n        if (index < taughtCount)\n            subjects[index].SetName(subjectName);\n        else\n            cout << \"âŒ Subject index out of range.\\n\";\n    }\n\n    void PrintInfo() override {\n        cout << \"ğŸ‘¤ Name: \" << name << \"\\nğŸ”° Role: Staff\\n\";\n        if (taughtCount == 0)\n            cout << \"ğŸ“š No subjects taught.\\n\";\n        else {\n            for (int i = 0; i < taughtCount; ++i)\n                cout << \"ğŸ“˜ Subject \" << i + 1 << \": \" << subjects[i].GetName() << \"\\n\";\n        }\n        cout << \"----------------------------------------\\n\";\n    }\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ ITI\nclass ITI {\n    Person** people;\n    int count;\npublic:\n    ITI(Person** p, int size) : count(size) {\n        people = new Person*[count];\n        for (int i = 0; i < count; ++i)\n            people[i] = p[i];\n    }\n\n    void PrintAllPeopleInfo() {\n        cout << \"\\nğŸ“‹ All ITI People Info:\\n\";\n        for (int i = 0; i < count; ++i)\n            people[i]->PrintInfo();\n    }\n\n    ~ITI() {\n        delete[] people;\n    }\n};\n\n// âœ… Ø¯Ø§Ù„Ø© main\nint main() {\n    string studentSubjects[5] = {\"Math\", \"Physics\", \"Biology\", \"Chemistry\", \"English\"};\n    string staffSubjects[3] = {\"Math\", \"Physics\", \"AI\"};\n\n    Student st1(\"Mahmoud\", studentSubjects, 5);\n    Staff sf1(\"Ahmed\", staffSubjects, 3);\n\n    st1.AddSubject(\"History\");\n    st1.SetSubject(\"Advanced Math\", 0);\n\n    Person* people[2] = {&st1, &sf1};\n    ITI institute(people, 2);\n\n    st1.PrintInfo();\n    sf1.PrintInfo();\n    institute.PrintAllPeopleInfo();\n\n    return 0;\n}\n\n```\nâ€«ğŸ’¡ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:â€¬\nâ€«Ø§Ù„ÙƒÙˆØ¯ Ù…Ù†Ø¸Ù… ÙˆÙŠØ­Ù‚Ù‚ ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ø¨.â€¬\nâ€«â€¬\nâ€«Ø§Ø³ØªØ®Ø¯Ù…Ù†Ø§ std::string Ù„ØªÙØ§Ø¯ÙŠ Ù…Ø´Ø§ÙƒÙ„ char[].â€¬\nâ€«â€¬\nâ€«ÙƒÙ„ ÙƒÙ„Ø§Ø³ ÙÙŠÙ‡ Ø¯ÙˆØ§Ù„ AddSubject, SetSubject, Ùˆ PrintInfo.â€¬\nâ€«â€¬\nâ€«ÙƒÙ„Ø§Ø³ ITI Ø¨ÙŠØ¬Ù…Ø¹ Ø§Ù„Ø£Ø´Ø®Ø§Øµ ÙˆÙŠØ·Ø¨Ø¹ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ù….â€¬",
    "created_at": "2025-08-21T01:23:04.593677",
    "page": 0
  },
  {
    "id": 294,
    "question": "Design and implement the following using C++ Programming Language\n\n25. ITI is an educational institute consists of students. Each of them studies some subjects that may differ from student to another and can be changed. Also, it has a staff that teaches these subjects.\n\n1. Extract the classes from the last sentences (5 Marks) 2. State their relation between them (4 Marks) 3. Implement the above classes (5 Marks) 4. Design and Implement a new class named ITI that consists of number of people (Student and/or Staff) (5 Marks) 5. Make a member function in the ITI that prints all people data. (6 Marks)\n\n(25 Points)\n\nDo NOT refer to the image by its URL.",
    "options": [
      {
        "id": "A",
        "text": "View Answer"
      },
      {
        "id": "B",
        "text": "View Answer"
      }
    ],
    "correct_answer": "A",
    "explanation": "```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// âœ… ÙƒÙ„Ø§Ø³ Subject\nclass Subject {\n    string name;\npublic:\n    Subject() {}\n    Subject(string n) : name(n) {}\n    string GetName() { return name; }\n    void SetName(string n) { name = n; }\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ Person (Ø£Ø³Ø§Ø³ÙŠ ÙˆÙ…Ø¬Ø±Ø¯)\nclass Person {\nprotected:\n    string name;\npublic:\n    Person(string n) : name(n) {}\n    string GetName() { return name; }\n    void SetName(string n) { name = n; }\n    virtual void PrintInfo() = 0; // Ø¯Ø§Ù„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ Student\nclass Student : public Person {\n    Subject subjects[7];\n    int subjectCount;\npublic:\n    Student(string n) : Person(n), subjectCount(0) {}\n\n    Student(string n, string subjectNames[], int count) : Person(n) {\n        if (count <= 7) {\n            subjectCount = count;\n            for (int i = 0; i < count; ++i)\n                subjects[i].SetName(subjectNames[i]);\n        } else {\n            cout << \"âŒ Can't add more than 7 subjects.\\n\";\n            subjectCount = 0;\n        }\n    }\n\n    void AddSubject(string subjectName) {\n        if (subjectCount < 7)\n            subjects[subjectCount++].SetName(subjectName);\n        else\n            cout << \"âŒ Student can't have more than 7 subjects.\\n\";\n    }\n\n    void SetSubject(string subjectName, int index) {\n        if (index < subjectCount)\n            subjects[index].SetName(subjectName);\n        else\n            cout << \"âŒ Subject index out of range.\\n\";\n    }\n\n    void PrintInfo() override {\n        cout << \"ğŸ‘¤ Name: \" << name << \"\\nğŸ”° Role: Student\\n\";\n        if (subjectCount == 0)\n            cout << \"ğŸ“š No subjects enrolled.\\n\";\n        else {\n            for (int i = 0; i < subjectCount; ++i)\n                cout << \"ğŸ“˜ Subject \" << i + 1 << \": \" << subjects[i].GetName() << \"\\n\";\n        }\n        cout << \"----------------------------------------\\n\";\n    }\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ Staff\nclass Staff : public Person {\n    Subject subjects[3];\n    int taughtCount;\npublic:\n    Staff(string n) : Person(n), taughtCount(0) {}\n\n    Staff(string n, string subjectNames[], int count) : Person(n) {\n        if (count <= 3) {\n            taughtCount = count;\n            for (int i = 0; i < count; ++i)\n                subjects[i].SetName(subjectNames[i]);\n        } else {\n            cout << \"âŒ Can't teach more than 3 subjects.\\n\";\n            taughtCount = 0;\n        }\n    }\n\n    void AddSubject(string subjectName) {\n        if (taughtCount < 3)\n            subjects[taughtCount++].SetName(subjectName);\n        else\n            cout << \"âŒ Staff can't teach more than 3 subjects.\\n\";\n    }\n\n    void SetSubject(string subjectName, int index) {\n        if (index < taughtCount)\n            subjects[index].SetName(subjectName);\n        else\n            cout << \"âŒ Subject index out of range.\\n\";\n    }\n\n    void PrintInfo() override {\n        cout << \"ğŸ‘¤ Name: \" << name << \"\\nğŸ”° Role: Staff\\n\";\n        if (taughtCount == 0)\n            cout << \"ğŸ“š No subjects taught.\\n\";\n        else {\n            for (int i = 0; i < taughtCount; ++i)\n                cout << \"ğŸ“˜ Subject \" << i + 1 << \": \" << subjects[i].GetName() << \"\\n\";\n        }\n        cout << \"----------------------------------------\\n\";\n    }\n};\n\n// âœ… ÙƒÙ„Ø§Ø³ ITI\nclass ITI {\n    Person** people;\n    int count;\npublic:\n    ITI(Person** p, int size) : count(size) {\n        people = new Person*[count];\n        for (int i = 0; i < count; ++i)\n            people[i] = p[i];\n    }\n\n    void PrintAllPeopleInfo() {\n        cout << \"\\nğŸ“‹ All ITI People Info:\\n\";\n        for (int i = 0; i < count; ++i)\n            people[i]->PrintInfo();\n    }\n\n    ~ITI() {\n        delete[] people;\n    }\n};\n\n// âœ… Ø¯Ø§Ù„Ø© main\nint main() {\n    string studentSubjects[5] = {\"Math\", \"Physics\", \"Biology\", \"Chemistry\", \"English\"};\n    string staffSubjects[3] = {\"Math\", \"Physics\", \"AI\"};\n\n    Student st1(\"Mahmoud\", studentSubjects, 5);\n    Staff sf1(\"Ahmed\", staffSubjects, 3);\n\n    st1.AddSubject(\"History\");\n    st1.SetSubject(\"Advanced Math\", 0);\n\n    Person* people[2] = {&st1, &sf1};\n    ITI institute(people, 2);\n\n    st1.PrintInfo();\n    sf1.PrintInfo();\n    institute.PrintAllPeopleInfo();\n\n    return 0;\n}\n```",
    "created_at": "2025-08-21T01:25:33.254733",
    "page": 0
  }
]